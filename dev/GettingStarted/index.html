<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started ¬∑ RootSolvers.jl</title><meta name="title" content="Getting Started ¬∑ RootSolvers.jl"/><meta property="og:title" content="Getting Started ¬∑ RootSolvers.jl"/><meta property="twitter:title" content="Getting Started ¬∑ RootSolvers.jl"/><meta name="description" content="Documentation for RootSolvers.jl."/><meta property="og:description" content="Documentation for RootSolvers.jl."/><meta property="twitter:description" content="Documentation for RootSolvers.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="RootSolvers.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">RootSolvers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Getting Started</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Quick-Start-Example"><span>Quick Start Example</span></a></li><li><a class="tocitem" href="#How-to-Guide"><span>How-to Guide</span></a></li><li><a class="tocitem" href="#Automatic-Differentiation-and-Dual-Number-Support"><span>Automatic Differentiation and Dual Number Support üîÑ</span></a></li><li><a class="tocitem" href="#High-Performance-and-GPU-Computing"><span>High-Performance and GPU Computing üöÄ</span></a></li><li><a class="tocitem" href="#Reference-Tables"><span>Reference Tables</span></a></li><li><a class="tocitem" href="#Troubleshooting"><span>Troubleshooting</span></a></li><li><a class="tocitem" href="#Extending-RootSolvers.jl"><span>Extending RootSolvers.jl</span></a></li></ul></li><li><a class="tocitem" href="../API/">API</a></li><li><a class="tocitem" href="../DeveloperDocs/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting Started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/RootSolvers.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/RootSolvers.jl/blob/main/docs/src/GettingStarted.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-Started"><a class="docs-heading-anchor" href="#Getting-Started">Getting Started</a><a id="Getting-Started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Started" title="Permalink"></a></h1><p>RootSolvers.jl is a Julia package for finding roots of nonlinear equations using robust, efficient, and GPU-capable numerical methods. It provides a simple, unified interface for a variety of classic root-finding algorithms, with flexible convergence criteria and solution reporting.</p><hr/><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>The package is registered in the Julia General registry.</p><p><strong>Stable Release:</strong></p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;RootSolvers&quot;)</code></pre><hr/><h2 id="Quick-Start-Example"><a class="docs-heading-anchor" href="#Quick-Start-Example">Quick Start Example</a><a id="Quick-Start-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start-Example" title="Permalink"></a></h2><pre><code class="language-julia hljs">using RootSolvers
# Find the root of x^2 - 100^2 using the secant method
sol = find_zero(x -&gt; x^2 - 100^2, SecantMethod(0.0, 1000.0))
sol</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CompactSolutionResults{Float64}:
‚îú‚îÄ‚îÄ Status: <span class="sgr32">converged</span>
‚îî‚îÄ‚îÄ Root: 99.99999999994358</code></pre><p>The numerical value of the root is contained in <code>sol.root</code>:</p><pre><code class="language-julia hljs">sol.root</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">99.99999999994358</code></pre><hr/><h2 id="How-to-Guide"><a class="docs-heading-anchor" href="#How-to-Guide">How-to Guide</a><a id="How-to-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-Guide" title="Permalink"></a></h2><p>This guide shows the basic steps for solving a root-finding problem.</p><h3 id="General-Workflow"><a class="docs-heading-anchor" href="#General-Workflow">General Workflow</a><a id="General-Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#General-Workflow" title="Permalink"></a></h3><h4 id="Step-1:-Define-Your-Function"><a class="docs-heading-anchor" href="#Step-1:-Define-Your-Function">Step 1: Define Your Function</a><a id="Step-1:-Define-Your-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Define-Your-Function" title="Permalink"></a></h4><p>Write your function as a Julia callable.</p><pre><code class="language-julia hljs">f(x) = x^3 - 2x - 5</code></pre><h4 id="Step-2:-Choose-a-Root-Finding-Method"><a class="docs-heading-anchor" href="#Step-2:-Choose-a-Root-Finding-Method">Step 2: Choose a Root-Finding Method</a><a id="Step-2:-Choose-a-Root-Finding-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Choose-a-Root-Finding-Method" title="Permalink"></a></h4><p>Pick a method and provide initial guesses. The type parameter (e.g., <code>Float64</code>) is often inferred automatically.</p><pre><code class="language-julia hljs"># For SecantMethod, provide two initial guesses
method = SecantMethod(1.0, 3.0)</code></pre><h4 id="Step-3:-(Optional)-Set-Tolerance-and-Solution-Type"><a class="docs-heading-anchor" href="#Step-3:-(Optional)-Set-Tolerance-and-Solution-Type">Step 3: (Optional) Set Tolerance and Solution Type</a><a id="Step-3:-(Optional)-Set-Tolerance-and-Solution-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-(Optional)-Set-Tolerance-and-Solution-Type" title="Permalink"></a></h4><p>Customize the convergence criteria and the level of detail in the output.</p><pre><code class="language-julia hljs"># Stop when iterates are closer than 1e-6
tol = SolutionTolerance(1e-6)

# Request detailed output for debugging
soltype = VerboseSolution()</code></pre><h4 id="Step-4:-Call-find_zero"><a class="docs-heading-anchor" href="#Step-4:-Call-find_zero">Step 4: Call <code>find_zero</code></a><a id="Step-4:-Call-find_zero-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Call-find_zero" title="Permalink"></a></h4><p>All arguments after <code>method</code> are optional.</p><pre><code class="language-julia hljs">sol = find_zero(f, method, soltype, tol)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VerboseSolutionResults{Float64}:
‚îú‚îÄ‚îÄ Status: <span class="sgr32">converged</span>
‚îú‚îÄ‚îÄ Root: 2.094551481542313
‚îú‚îÄ‚îÄ Error: -1.4832579608992091e-13
‚îú‚îÄ‚îÄ Iterations: 8
‚îî‚îÄ‚îÄ History:
    ‚îú‚îÄ‚îÄ iter  1: x =        1, err = -6
    ‚îú‚îÄ‚îÄ iter  2: x =   1.5455, err = -4.4
    ‚îú‚îÄ‚îÄ iter  3: x =   1.8592, err = -2.292
    ‚îú‚îÄ‚îÄ iter  4: x =   2.2004, err = 1.252
    ‚îú‚îÄ‚îÄ iter  5: x =   2.0798, err = -0.1633
    ‚îú‚îÄ‚îÄ iter  6: x =   2.0937, err = -0.009452
    ‚îú‚îÄ‚îÄ iter  7: x =   2.0946, err = 7.904e-05
    ‚îú‚îÄ‚îÄ iter  8: x =   2.0946, err = -3.771e-08
    ‚îî‚îÄ‚îÄ iter  9: x =   2.0946, err = -1.483e-13
</code></pre><h4 id="Step-5:-Interpret-Results"><a class="docs-heading-anchor" href="#Step-5:-Interpret-Results">Step 5: Interpret Results</a><a id="Step-5:-Interpret-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5:-Interpret-Results" title="Permalink"></a></h4><ul><li><code>sol.converged</code>: <code>true</code> if a root was found.</li><li><code>sol.root</code>: The root value.</li><li><code>sol.err</code>, <code>sol.iter_performed</code>, <code>sol.root_history</code> (available with <a href="../API/#RootSolvers.VerboseSolution"><code>VerboseSolution</code></a>).</li></ul><h3 id="Specific-Example:-Newton&#39;s-Method-with-a-Provided-Derivative"><a class="docs-heading-anchor" href="#Specific-Example:-Newton&#39;s-Method-with-a-Provided-Derivative">Specific Example: Newton&#39;s Method with a Provided Derivative</a><a id="Specific-Example:-Newton&#39;s-Method-with-a-Provided-Derivative-1"></a><a class="docs-heading-anchor-permalink" href="#Specific-Example:-Newton&#39;s-Method-with-a-Provided-Derivative" title="Permalink"></a></h3><p>When using <a href="../API/#RootSolvers.NewtonsMethod"><code>NewtonsMethod</code></a>, you must provide a function that returns both the value <code>f(x)</code> and its derivative <code>f&#39;(x)</code> as a tuple. This avoids the overhead of automatic differentiation and is highly efficient if you can provide an analytical derivative.</p><h4 id="Step-1:-Define-Function-and-Derivative"><a class="docs-heading-anchor" href="#Step-1:-Define-Function-and-Derivative">Step 1: Define Function and Derivative</a><a id="Step-1:-Define-Function-and-Derivative-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Define-Function-and-Derivative" title="Permalink"></a></h4><pre><code class="language-julia hljs"># This function finds the root of f(x) = x^2 - 4.
# It returns the tuple (f(x), f&#39;(x)).
f_with_deriv(x) = (x^2 - 4, 2x)</code></pre><h4 id="Step-2:-Choose-the-Method-and-Call-find_zero"><a class="docs-heading-anchor" href="#Step-2:-Choose-the-Method-and-Call-find_zero">Step 2: Choose the Method and Call <code>find_zero</code></a><a id="Step-2:-Choose-the-Method-and-Call-find_zero-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Choose-the-Method-and-Call-find_zero" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Provide a single initial guess for Newton&#39;s method
method = NewtonsMethod(1.0)

# The function f_with_deriv is passed to find_zero
sol = find_zero(f_with_deriv, method)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CompactSolutionResults{Float64}:
‚îú‚îÄ‚îÄ Status: <span class="sgr32">converged</span>
‚îî‚îÄ‚îÄ Root: 2.000000000000002</code></pre><h3 id="Specific-Example:-Brent&#39;s-Method-for-Robust-Root-Finding"><a class="docs-heading-anchor" href="#Specific-Example:-Brent&#39;s-Method-for-Robust-Root-Finding">Specific Example: Brent&#39;s Method for Robust Root Finding</a><a id="Specific-Example:-Brent&#39;s-Method-for-Robust-Root-Finding-1"></a><a class="docs-heading-anchor-permalink" href="#Specific-Example:-Brent&#39;s-Method-for-Robust-Root-Finding" title="Permalink"></a></h3><p>Brent&#39;s method combines the bisection method, secant method, and inverse quadratic interpolation. It provides superlinear convergence while maintaining the robustness of bracketing methods.</p><h4 id="Step-1:-Define-Your-Function-2"><a class="docs-heading-anchor" href="#Step-1:-Define-Your-Function-2">Step 1: Define Your Function</a><a class="docs-heading-anchor-permalink" href="#Step-1:-Define-Your-Function-2" title="Permalink"></a></h4><pre><code class="language-julia hljs">using RootSolvers
# This function finds the root of f(x) = x^3 - 2.
f(x) = x^3 - 2</code></pre><h4 id="Step-2:-Choose-the-Method-and-Call-find_zero-2"><a class="docs-heading-anchor" href="#Step-2:-Choose-the-Method-and-Call-find_zero-2">Step 2: Choose the Method and Call <code>find_zero</code></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Choose-the-Method-and-Call-find_zero-2" title="Permalink"></a></h4><pre><code class="language-julia hljs"># Provide a bracketing interval where f(x0) and f(x1) have opposite signs
method = BrentsMethod(-1.0, 2.0)  # f(-1) = -3, f(2) = 6

# Solve the root-finding problem
sol = find_zero(f, method)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CompactSolutionResults{Float64}:
‚îú‚îÄ‚îÄ Status: <span class="sgr32">converged</span>
‚îî‚îÄ‚îÄ Root: 1.2599210498950593</code></pre><hr/><h2 id="Automatic-Differentiation-and-Dual-Number-Support"><a class="docs-heading-anchor" href="#Automatic-Differentiation-and-Dual-Number-Support">Automatic Differentiation and Dual Number Support üîÑ</a><a id="Automatic-Differentiation-and-Dual-Number-Support-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Differentiation-and-Dual-Number-Support" title="Permalink"></a></h2><p>RootSolvers.jl is fully compatible with automatic differentiation frameworks, making it suitable for integration into differentiable models and optimization problems. The package supports dual numbers (from ForwardDiff.jl and other AD packages) as input arguments, allowing gradients to flow through root-finding computations. Dual number support works on GPU arrays when using compatible AD frameworks.</p><h3 id="Using-RootSolvers-in-Differentiable-Models"><a class="docs-heading-anchor" href="#Using-RootSolvers-in-Differentiable-Models">Using RootSolvers in Differentiable Models</a><a id="Using-RootSolvers-in-Differentiable-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Using-RootSolvers-in-Differentiable-Models" title="Permalink"></a></h3><p>When your function <code>f(x)</code> accepts dual numbers, RootSolvers.jl can be used within larger differentiable computations:</p><pre><code class="language-julia hljs">using RootSolvers, ForwardDiff

# Create a function that uses root finding
function solve_and_evaluate(Œ∏)
    # Œ∏ is a parameter that affects the root-finding problem
    f(x) = x^3 - Œ∏ * x - 5
    sol = find_zero(f, SecantMethod(1.0, 3.0))
    return sol.root
end

# Compute the derivative with respect to Œ∏
Œ∏ = 2.0
deriv = ForwardDiff.derivative(solve_and_evaluate, Œ∏)
println(&quot;Derivative: &quot;, deriv)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Derivative: 0.187659649918941</code></pre><p>This enables integration, for example, with derivative-based optimization algorithms, when an objective function may include a root finding problem.</p><h2 id="High-Performance-and-GPU-Computing"><a class="docs-heading-anchor" href="#High-Performance-and-GPU-Computing">High-Performance and GPU Computing üöÄ</a><a id="High-Performance-and-GPU-Computing-1"></a><a class="docs-heading-anchor-permalink" href="#High-Performance-and-GPU-Computing" title="Permalink"></a></h2><p>RootSolvers.jl is designed for high-performance computing, supporting broadcasting over custom data structures and GPU acceleration. This makes it ideal for solving many problems in parallel.</p><h3 id="Broadcasting-with-Abstract-Types"><a class="docs-heading-anchor" href="#Broadcasting-with-Abstract-Types">Broadcasting with Abstract Types</a><a id="Broadcasting-with-Abstract-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting-with-Abstract-Types" title="Permalink"></a></h3><p>The package works seamlessly with any abstract type that supports broadcasting, making it well-suited for scientific domains like climate modeling.</p><h3 id="Example:-Solving-over-a-custom-field-type"><a class="docs-heading-anchor" href="#Example:-Solving-over-a-custom-field-type">Example: Solving over a custom field type</a><a id="Example:-Solving-over-a-custom-field-type-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Solving-over-a-custom-field-type" title="Permalink"></a></h3><pre><code class="language-julia hljs">using RootSolvers

# Example using regular arrays to represent a field grid
x0 = rand(10, 10)  # A 10x10 field of initial guesses
x1 = x0 .+ 1       # A second field of initial guesses

# Define a function that operates element-wise on the field
f(x) = x^2 - 2

# Solve the root-finding problem across the entire field
method = SecantMethod(x0, x1)
sol = find_zero.(f, method, CompactSolution()) # sol is an Array of structs</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10√ó10 Matrix{RootSolvers.CompactSolutionResults{Float64}}:
 <span class="sgr32">1.41422</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.4142</span>   <span class="sgr32">1.41421</span>  ‚Ä¶  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>
 <span class="sgr32">1.41421</span>  <span class="sgr32">1.41422</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>     <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>
 <span class="sgr32">1.41423</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>     <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>
 <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41422</span>  <span class="sgr32">1.41421</span>     <span class="sgr32">1.41422</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>
 <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>     <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>
 <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  ‚Ä¶  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>
 <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>     <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>
 <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>     <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>
 <span class="sgr32">1.41421</span>  <span class="sgr32">1.41422</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>     <span class="sgr32">1.41421</span>  <span class="sgr32">1.41451</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>
 <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>     <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41421</span>  <span class="sgr32">1.41422</span></code></pre><p>Use <code>getproperty.()</code> to extract the fields from each struct in the array:</p><pre><code class="language-julia hljs">converged_field = getproperty.(sol, :converged)
root_field = getproperty.(sol, :root)

println(&quot;All converged: &quot;, all(converged_field))
println(&quot;Root field shape: &quot;, size(root_field))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">All converged: true
Root field shape: (10, 10)</code></pre><h3 id="GPU-Acceleration-for-Batch-Processing"><a class="docs-heading-anchor" href="#GPU-Acceleration-for-Batch-Processing">GPU Acceleration for Batch Processing</a><a id="GPU-Acceleration-for-Batch-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-Acceleration-for-Batch-Processing" title="Permalink"></a></h3><p>You can achieve significant speedups by running large batches of problems on a GPU.</p><div class="admonition is-info" id="GPU-Backends-78fd763bd8f71b6e"><header class="admonition-header">GPU Backends<a class="admonition-anchor" href="#GPU-Backends-78fd763bd8f71b6e" title="Permalink"></a></header><div class="admonition-body"><p>The following examples use <a href="https://cuda.juliagpu.org/stable/">&#39;CUDA.jl`</a>, but similar results can be achieved for different GPU backends with <a href="https://juliagpu.github.io/KernelAbstractions.jl/stable/"><code>KernelAbstractions.jl</code></a>.</p></div></div><h3 id="GPU-Usage-Tips"><a class="docs-heading-anchor" href="#GPU-Usage-Tips">GPU Usage Tips</a><a id="GPU-Usage-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#GPU-Usage-Tips" title="Permalink"></a></h3><ul><li><strong>Use<a href="../API/#RootSolvers.CompactSolution"><code>CompactSolution</code></a>:</strong> Only <a href="../API/#RootSolvers.CompactSolution"><code>CompactSolution</code></a> is GPU-friendly. <a href="../API/#RootSolvers.VerboseSolution"><code>VerboseSolution</code></a> is for CPU debugging only.</li><li><strong>GPU-Compatible Function:</strong> Ensure your function <code>f(x)</code> uses only GPU-supported operations.</li><li><strong>Minimize Data Transfer:</strong> Keep initial guesses and results on the GPU.</li></ul><h3 id="Broadcasting-Example:-1-Million-problems-on-the-GPU"><a class="docs-heading-anchor" href="#Broadcasting-Example:-1-Million-problems-on-the-GPU">Broadcasting Example: 1 Million problems on the GPU</a><a id="Broadcasting-Example:-1-Million-problems-on-the-GPU-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting-Example:-1-Million-problems-on-the-GPU" title="Permalink"></a></h3><pre><code class="language-julia hljs">using RootSolvers, CUDA

# Create GPU arrays for batch processing
x0 = CUDA.fill(1.0f0, 1000, 1000)  # 1M initial guesses on GPU
x1 = CUDA.fill(2.0f0, 1000, 1000)  # Second initial guesses

# Define GPU-compatible function
f(x) = x^3 - x - 2

# Solve all problems in parallel using broadcasting
# Pass the method type directly for efficient dispatch
sol = find_zero.(f, SecantMethod, x0, x1, CompactSolution()) # broadcast launches kernel

# Results are on the GPU as an array of CompactSolutions
converged_field = map(sol_i -&gt; sol_i.converged, sol)
root_field = map(sol_i -&gt; sol_i.root, sol)

println(&quot;All converged: &quot;, all(converged_field)) # Ouput: &quot;All converged: true&quot;
println(&quot;Root field shape: &quot;, size(root_field)) # Output &quot;Root field shape: (1000, 1000)&quot;</code></pre><h3 id="Map-Example:-1-Million-problems-on-the-GPU"><a class="docs-heading-anchor" href="#Map-Example:-1-Million-problems-on-the-GPU">Map Example: 1 Million problems on the GPU</a><a id="Map-Example:-1-Million-problems-on-the-GPU-1"></a><a class="docs-heading-anchor-permalink" href="#Map-Example:-1-Million-problems-on-the-GPU" title="Permalink"></a></h3><pre><code class="language-julia hljs">using RootSolvers, CUDA

# Create GPU arrays for batch processing
x0 = CUDA.fill(1.0f0, 1000, 1000)  # 1M initial guesses on GPU
x1 = CUDA.fill(2.0f0, 1000, 1000)  # Second initial guesses

# Define GPU-compatible function
f(x) = x^3 - x - 2

# Solve all problems in parallel using map
sol = map(x0, x1) do x0, x1 # map launches kernel
    find_zero(f, SecantMethod, x0, x1, CompactSolution())
end

# Results are on the GPU as an array of CompactSolutions
converged_field = map(sol_i -&gt; sol_i.converged, sol)
root_field = map(sol_i -&gt; sol_i.root, sol)

println(&quot;All converged: &quot;, all(converged_field)) # Ouput: &quot;All converged: true&quot;
println(&quot;Root field shape: &quot;, size(root_field)) # Output &quot;Root field shape: (1000, 1000)&quot;</code></pre><hr/><h2 id="Reference-Tables"><a class="docs-heading-anchor" href="#Reference-Tables">Reference Tables</a><a id="Reference-Tables-1"></a><a class="docs-heading-anchor-permalink" href="#Reference-Tables" title="Permalink"></a></h2><h3 id="Available-Root-Finding-Methods"><a class="docs-heading-anchor" href="#Available-Root-Finding-Methods">Available Root-Finding Methods</a><a id="Available-Root-Finding-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Available-Root-Finding-Methods" title="Permalink"></a></h3><table><tr><th style="text-align: left">Method</th><th style="text-align: left">Requirements</th><th style="text-align: left">Best For</th></tr><tr><td style="text-align: left"><a href="../API/#RootSolvers.SecantMethod"><code>SecantMethod</code></a></td><td style="text-align: left">2 initial guesses</td><td style="text-align: left">No derivatives, <strong>fast</strong> convergence</td></tr><tr><td style="text-align: left"><a href="../API/#RootSolvers.RegulaFalsiMethod"><code>RegulaFalsiMethod</code></a></td><td style="text-align: left">Bracketing interval</td><td style="text-align: left"><strong>Guaranteed</strong> convergence</td></tr><tr><td style="text-align: left"><a href="../API/#RootSolvers.BisectionMethod"><code>BisectionMethod</code></a></td><td style="text-align: left">Bracketing interval</td><td style="text-align: left"><strong>Guaranteed</strong> convergence, simple</td></tr><tr><td style="text-align: left"><a href="../API/#RootSolvers.BrentsMethod"><code>BrentsMethod</code></a></td><td style="text-align: left">Bracketing interval</td><td style="text-align: left"><strong>Superlinear</strong> convergence, robust</td></tr><tr><td style="text-align: left"><a href="../API/#RootSolvers.NewtonsMethodAD"><code>NewtonsMethodAD</code></a></td><td style="text-align: left">1 initial guess, differentiable <code>f</code></td><td style="text-align: left"><strong>Fastest</strong>, uses autodiff, robust step control</td></tr><tr><td style="text-align: left"><a href="../API/#RootSolvers.NewtonsMethod"><code>NewtonsMethod</code></a></td><td style="text-align: left">1 initial guess, <code>f</code> and <code>f&#39;</code> provided</td><td style="text-align: left"><strong>Analytical</strong> derivatives, robust step control</td></tr></table><h3 id="Available-Tolerance-Types"><a class="docs-heading-anchor" href="#Available-Tolerance-Types">Available Tolerance Types</a><a id="Available-Tolerance-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Available-Tolerance-Types" title="Permalink"></a></h3><table><tr><th style="text-align: left">Tolerance Type</th><th style="text-align: left">Criterion</th><th style="text-align: left">Best For</th></tr><tr><td style="text-align: left"><a href="../API/#RootSolvers.SolutionTolerance"><code>SolutionTolerance</code></a></td><td style="text-align: left"><code>abs(x‚ÇÇ - x‚ÇÅ)</code></td><td style="text-align: left">When you want iterates to <strong>stabilize</strong></td></tr><tr><td style="text-align: left"><a href="../API/#RootSolvers.ResidualTolerance"><code>ResidualTolerance</code></a></td><td style="text-align: left"><code>abs(f(x))</code></td><td style="text-align: left">When you want the function value near <strong>zero</strong></td></tr><tr><td style="text-align: left"><a href="../API/#RootSolvers.RelativeSolutionTolerance"><code>RelativeSolutionTolerance</code></a></td><td style="text-align: left"><code>abs((x‚ÇÇ - x‚ÇÅ)/x‚ÇÅ)</code></td><td style="text-align: left">When root magnitude <strong>varies widely</strong></td></tr><tr><td style="text-align: left"><a href="../API/#RootSolvers.RelativeOrAbsoluteSolutionTolerance"><code>RelativeOrAbsolute...</code></a></td><td style="text-align: left">Relative or Absolute</td><td style="text-align: left"><strong>Robust</strong> for both small and large roots</td></tr></table><h3 id="Available-Solution-Types"><a class="docs-heading-anchor" href="#Available-Solution-Types">Available Solution Types</a><a id="Available-Solution-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Available-Solution-Types" title="Permalink"></a></h3><table><tr><th style="text-align: left">Solution Type</th><th style="text-align: left">Features</th><th style="text-align: left">Best For</th></tr><tr><td style="text-align: left"><a href="../API/#RootSolvers.CompactSolution"><code>CompactSolution</code></a></td><td style="text-align: left">Minimal output, GPU-friendly</td><td style="text-align: left"><strong>High-performance</strong>, GPU, memory efficiency</td></tr><tr><td style="text-align: left"><a href="../API/#RootSolvers.VerboseSolution"><code>VerboseSolution</code></a></td><td style="text-align: left">Full diagnostics, iteration history</td><td style="text-align: left"><strong>Debugging</strong>, analysis, CPU</td></tr></table><h3 id="Advanced-Features"><a class="docs-heading-anchor" href="#Advanced-Features">Advanced Features</a><a id="Advanced-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Features" title="Permalink"></a></h3><table><tr><th style="text-align: left">Feature</th><th style="text-align: left">Description</th><th style="text-align: left">Use Cases</th></tr><tr><td style="text-align: left"><strong>Dual Number Support</strong></td><td style="text-align: left">Compatible with automatic differentiation</td><td style="text-align: left"><strong>Differentiable models</strong>, optimization, gradient-based learning</td></tr><tr><td style="text-align: left"><strong>GPU Acceleration</strong></td><td style="text-align: left">Full CUDA.jl support with broadcasting</td><td style="text-align: left"><strong>Large-scale parallel processing</strong>, batch computations</td></tr><tr><td style="text-align: left"><strong>Custom Field Types</strong></td><td style="text-align: left">Works with any broadcastable type</td><td style="text-align: left"><strong>Scientific computing</strong>, climate modeling, custom data structures</td></tr></table><hr/><h2 id="Troubleshooting"><a class="docs-heading-anchor" href="#Troubleshooting">Troubleshooting</a><a id="Troubleshooting-1"></a><a class="docs-heading-anchor-permalink" href="#Troubleshooting" title="Permalink"></a></h2><ul><li>If not converging, try different initial guesses or a bracketing method such as <a href="../API/#RootSolvers.BrentsMethod"><code>BrentsMethod</code></a>.</li><li>Use <a href="../API/#RootSolvers.VerboseSolution"><code>VerboseSolution()</code></a> to inspect the iteration history and diagnose issues.</li><li>Adjust the tolerance for stricter or looser convergence criteria.</li></ul><h2 id="Extending-RootSolvers.jl"><a class="docs-heading-anchor" href="#Extending-RootSolvers.jl">Extending RootSolvers.jl</a><a id="Extending-RootSolvers.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Extending-RootSolvers.jl" title="Permalink"></a></h2><p>If you want to add custom root-finding methods, tolerance types, or solution formats, see the <a href="../DeveloperDocs/">Developer Documentation</a> for detailed guidance on extending the package.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">¬´ Home</a><a class="docs-footer-nextpage" href="../API/">API ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Friday 27 February 2026 21:25">Friday 27 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
