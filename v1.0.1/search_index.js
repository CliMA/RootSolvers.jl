var documenterSearchIndex = {"docs":
[{"location":"GettingStarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"RootSolvers.jl is a Julia package for finding roots of nonlinear equations using robust, efficient, and GPU-capable numerical methods. It provides a simple, unified interface for a variety of classic root-finding algorithms, with flexible convergence criteria and solution reporting.\n\n","category":"section"},{"location":"GettingStarted/#Installation","page":"Getting Started","title":"Installation","text":"The package is registered in the Julia General registry.\n\nStable Release:\n\nusing Pkg\nPkg.add(\"RootSolvers\")\n\n","category":"section"},{"location":"GettingStarted/#Quick-Start-Example","page":"Getting Started","title":"Quick Start Example","text":"using RootSolvers\n# Find the root of x^2 - 100^2 using the secant method\nsol = find_zero(x -> x^2 - 100^2, SecantMethod(0.0, 1000.0))\nsol\n\nThe numerical value of the root is contained in sol.root:\n\nsol.root\n\n","category":"section"},{"location":"GettingStarted/#How-to-Guide","page":"Getting Started","title":"How-to Guide","text":"This guide shows the basic steps for solving a root-finding problem.","category":"section"},{"location":"GettingStarted/#General-Workflow","page":"Getting Started","title":"General Workflow","text":"","category":"section"},{"location":"GettingStarted/#1.-Define-Your-Function","page":"Getting Started","title":"1. Define Your Function","text":"Write your function as a Julia callable.\n\nf(x) = x^3 - 2x - 5\nnothing # hide","category":"section"},{"location":"GettingStarted/#2.-Choose-a-Root-Finding-Method","page":"Getting Started","title":"2. Choose a Root-Finding Method","text":"Pick a method and provide initial guesses. The type parameter (e.g., Float64) is often inferred automatically.\n\n# For SecantMethod, provide two initial guesses\nmethod = SecantMethod(1.0, 3.0)\nnothing # hide","category":"section"},{"location":"GettingStarted/#3.-(Optional)-Set-Tolerance-and-Solution-Type","page":"Getting Started","title":"3. (Optional) Set Tolerance and Solution Type","text":"Customize the convergence criteria and the level of detail in the output.\n\n# Stop when iterates are closer than 1e-6\ntol = SolutionTolerance(1e-6)\n\n# Request detailed output for debugging\nsoltype = VerboseSolution()\nnothing # hide","category":"section"},{"location":"GettingStarted/#4.-Call-find_zero","page":"Getting Started","title":"4. Call find_zero","text":"All arguments after method are optional.\n\nsol = find_zero(f, method, soltype, tol)","category":"section"},{"location":"GettingStarted/#5.-Interpret-Results","page":"Getting Started","title":"5. Interpret Results","text":"sol.converged: true if a root was found.\nsol.root: The root value.\nsol.err, sol.iter_performed, sol.root_history (available with VerboseSolution).","category":"section"},{"location":"GettingStarted/#Specific-Example:-Newton's-Method-with-a-Provided-Derivative","page":"Getting Started","title":"Specific Example: Newton's Method with a Provided Derivative","text":"When using NewtonsMethod, you must provide a function that returns both the value f(x) and its derivative f'(x) as a tuple. This avoids the overhead of automatic differentiation and is highly efficient if you can provide an analytical derivative.","category":"section"},{"location":"GettingStarted/#1.-Define-Function-and-Derivative","page":"Getting Started","title":"1. Define Function and Derivative","text":"# This function finds the root of f(x) = x^2 - 4.\n# It returns the tuple (f(x), f'(x)).\nf_with_deriv(x) = (x^2 - 4, 2x)\nnothing # hide","category":"section"},{"location":"GettingStarted/#2.-Choose-the-Method-and-Call-find_zero","page":"Getting Started","title":"2. Choose the Method and Call find_zero","text":"# Provide a single initial guess for Newton's method\nmethod = NewtonsMethod(1.0)\n\n# The function f_with_deriv is passed to find_zero\nsol = find_zero(f_with_deriv, method)","category":"section"},{"location":"GettingStarted/#Specific-Example:-Brent's-Method-for-Robust-Root-Finding","page":"Getting Started","title":"Specific Example: Brent's Method for Robust Root Finding","text":"Brent's method combines the bisection method, secant method, and inverse quadratic interpolation. It provides superlinear convergence while maintaining the robustness of bracketing methods.","category":"section"},{"location":"GettingStarted/#1.-Define-Your-Function-2","page":"Getting Started","title":"1. Define Your Function","text":"# This function finds the root of f(x) = x^3 - 2.\nf(x) = x^3 - 2\nnothing # hide","category":"section"},{"location":"GettingStarted/#2.-Choose-the-Method-and-Call-find_zero-2","page":"Getting Started","title":"2. Choose the Method and Call find_zero","text":"# Provide a bracketing interval where f(x0) and f(x1) have opposite signs\nmethod = BrentsMethod(-1.0, 2.0)  # f(-1) = -3, f(2) = 6\n\n# Solve the root-finding problem\nsol = find_zero(f, method)\n\n","category":"section"},{"location":"GettingStarted/#Automatic-Differentiation-and-Dual-Number-Support","page":"Getting Started","title":"Automatic Differentiation and Dual Number Support üîÑ","text":"RootSolvers.jl is fully compatible with automatic differentiation frameworks, making it suitable for integration into differentiable models and optimization problems. The package supports dual numbers (from ForwardDiff.jl and other AD packages) as input arguments, allowing gradients to flow through root-finding computations. Dual number support works on GPU arrays when using compatible AD frameworks.","category":"section"},{"location":"GettingStarted/#Using-RootSolvers-in-Differentiable-Models","page":"Getting Started","title":"Using RootSolvers in Differentiable Models","text":"When your function f(x) accepts dual numbers, RootSolvers.jl can be used within larger differentiable computations:\n\nusing RootSolvers, ForwardDiff\n\n# Create a function that uses root finding\nfunction solve_and_evaluate(Œ∏)\n    # Œ∏ is a parameter that affects the root-finding problem\n    f(x) = x^3 - Œ∏ * x - 5\n    sol = find_zero(f, SecantMethod(1.0, 3.0))\n    return sol.root\nend\n\n# Compute the derivative with respect to Œ∏\nŒ∏ = 2.0\nderiv = ForwardDiff.derivative(solve_and_evaluate, Œ∏)\nprintln(\"Derivative: \", deriv)\n\nThis enables integration, for example, with derivative-based optimization algorithms, when an objective function may include a root finding problem. ","category":"section"},{"location":"GettingStarted/#High-Performance-and-GPU-Computing","page":"Getting Started","title":"High-Performance and GPU Computing üöÄ","text":"RootSolvers.jl is designed for high-performance computing, supporting broadcasting over custom data structures and GPU acceleration. This makes it ideal for solving many problems in parallel.","category":"section"},{"location":"GettingStarted/#Broadcasting-with-Abstract-Types","page":"Getting Started","title":"Broadcasting with Abstract Types","text":"The package works seamlessly with any abstract type that supports broadcasting, making it well-suited for scientific domains like climate modeling.\n\nExample: Solving over a custom field type\n\nusing RootSolvers\n\n# Example using regular arrays to represent a field grid\nx0 = rand(10, 10)  # A 10x10 field of initial guesses\nx1 = x0 .+ 1       # A second field of initial guesses\n\n# Define a function that operates element-wise on the field\nf(x) = x^2 - 2\n\n# Solve the root-finding problem across the entire field\nmethod = SecantMethod(x0, x1)\nsol = find_zero.(f, method, CompactSolution()) # sol is an Array of structs\n\nUse getproperty.() to extract the fields from each struct in the array:\n\nconverged_field = getproperty.(sol, :converged)\nroot_field = getproperty.(sol, :root)\n\nprintln(\"All converged: \", all(converged_field))\nprintln(\"Root field shape: \", size(root_field))","category":"section"},{"location":"GettingStarted/#GPU-Acceleration-for-Batch-Processing","page":"Getting Started","title":"GPU Acceleration for Batch Processing","text":"You can achieve significant speedups by running large batches of problems on a GPU.\n\nnote: GPU Backends\nThe following examples use 'CUDA.jl`, but similar results\ncan be achieved for different GPU backends with KernelAbstractions.jl.\n\nGPU Usage Tips:\n\nUseCompactSolution: Only CompactSolution is GPU-friendly. VerboseSolution is for CPU debugging only.\nGPU-Compatible Function: Ensure your function f(x) uses only GPU-supported operations.\nMinimize Data Transfer: Keep initial guesses and results on the GPU.\n\nBroadcasting Example: 1 Million problems on the GPU\n\nusing RootSolvers, CUDA\n\n# Create GPU arrays for batch processing\nx0 = CUDA.fill(1.0f0, 1000, 1000)  # 1M initial guesses on GPU\nx1 = CUDA.fill(2.0f0, 1000, 1000)  # Second initial guesses\n\n# Define GPU-compatible function\nf(x) = x^3 - x - 2\n\n# Solve all problems in parallel using broadcasting\nmethod = SecantMethod(x0, x1) # method = SecantMethod.(x0, x1) is also supported\nsol = find_zero.(f, method, CompactSolution()) # broadcast launches kernel\n\n# Results are on the GPU as an array of CompactSolutions\nconverged_field = map(sol_i -> sol_i.converged, sol)\nroot_field = map(sol_i -> sol_i.root, sol)\n\nprintln(\"All converged: \", all(converged_field)) # Ouput: \"All converged: true\"\nprintln(\"Root field shape: \", size(root_field)) # Output \"Root field shape: (1000, 1000)\"\n\nMap Example: 1 Million problems on the GPU\n\nusing RootSolvers, CUDA\n\n# Create GPU arrays for batch processing\nx0 = CUDA.fill(1.0f0, 1000, 1000)  # 1M initial guesses on GPU\nx1 = CUDA.fill(2.0f0, 1000, 1000)  # Second initial guesses\n\n# Define GPU-compatible function\nf(x) = x^3 - x - 2\n\n# Solve all problems in parallel using map\nconst METHOD = SecantMethod\nsol = map(x0, x1) do x0, x1 # map launches kernel\n    find_zero(f, METHOD(x0, x1), CompactSolution())\nend\n\n# Results are on the GPU as an array of CompactSolutions\nconverged_field = map(sol_i -> sol_i.converged, sol)\nroot_field = map(sol_i -> sol_i.root, sol)\n\nprintln(\"All converged: \", all(converged_field)) # Ouput: \"All converged: true\"\nprintln(\"Root field shape: \", size(root_field)) # Output \"Root field shape: (1000, 1000)\"\n\n","category":"section"},{"location":"GettingStarted/#Reference-Tables","page":"Getting Started","title":"Reference Tables","text":"","category":"section"},{"location":"GettingStarted/#Available-Root-Finding-Methods","page":"Getting Started","title":"Available Root-Finding Methods","text":"Method Requirements Best For\nSecantMethod 2 initial guesses No derivatives, fast convergence\nRegulaFalsiMethod Bracketing interval Guaranteed convergence\nBisectionMethod Bracketing interval Guaranteed convergence, simple\nBrentsMethod Bracketing interval Superlinear convergence, robust\nNewtonsMethodAD 1 initial guess, differentiable f Fastest, uses autodiff, robust step control\nNewtonsMethod 1 initial guess, f and f' provided Analytical derivatives, robust step control","category":"section"},{"location":"GettingStarted/#Available-Tolerance-Types","page":"Getting Started","title":"Available Tolerance Types","text":"Tolerance Type Criterion Best For\nSolutionTolerance abs(x‚ÇÇ - x‚ÇÅ) When you want iterates to stabilize\nResidualTolerance abs(f(x)) When you want the function value near zero\nRelativeSolutionTolerance abs((x‚ÇÇ - x‚ÇÅ)/x‚ÇÅ) When root magnitude varies widely\nRelativeOrAbsolute... Relative or Absolute Robust for both small and large roots","category":"section"},{"location":"GettingStarted/#Available-Solution-Types","page":"Getting Started","title":"Available Solution Types","text":"Solution Type Features Best For\nCompactSolution Minimal output, GPU-friendly High-performance, GPU, memory efficiency\nVerboseSolution Full diagnostics, iteration history Debugging, analysis, CPU","category":"section"},{"location":"GettingStarted/#Advanced-Features","page":"Getting Started","title":"Advanced Features","text":"Feature Description Use Cases\nDual Number Support Compatible with automatic differentiation Differentiable models, optimization, gradient-based learning\nGPU Acceleration Full CUDA.jl support with broadcasting Large-scale parallel processing, batch computations\nCustom Field Types Works with any broadcastable type Scientific computing, climate modeling, custom data structures\n\n","category":"section"},{"location":"GettingStarted/#Troubleshooting","page":"Getting Started","title":"Troubleshooting","text":"If not converging, try different initial guesses or a bracketing method such as BrentsMethod.\nUse VerboseSolution() to inspect the iteration history and diagnose issues.\nAdjust the tolerance for stricter or looser convergence criteria.","category":"section"},{"location":"GettingStarted/#Extending-RootSolvers.jl","page":"Getting Started","title":"Extending RootSolvers.jl","text":"If you want to add custom root-finding methods, tolerance types, or solution formats, see the Developer Documentation for detailed guidance on extending the package.","category":"section"},{"location":"DeveloperDocs/#Developer-Documentation","page":"Developer Documentation","title":"Developer Documentation","text":"This section contains documentation for internal methods and developer-focused functionality that may be useful for advanced development and extending RootSolvers.jl.","category":"section"},{"location":"DeveloperDocs/#Internal-Methods","page":"Developer Documentation","title":"Internal Methods","text":"These functions are used internally by the solvers but are exported and may be useful for advanced development.","category":"section"},{"location":"DeveloperDocs/#Core-Types","page":"Developer Documentation","title":"Core Types","text":"","category":"section"},{"location":"DeveloperDocs/#RootSolvingMethod","page":"Developer Documentation","title":"RootSolvingMethod","text":"","category":"section"},{"location":"DeveloperDocs/#SolutionType","page":"Developer Documentation","title":"SolutionType","text":"","category":"section"},{"location":"DeveloperDocs/#Extending-RootSolvers.jl","page":"Developer Documentation","title":"Extending RootSolvers.jl","text":"","category":"section"},{"location":"DeveloperDocs/#Adding-New-Root-Finding-Methods","page":"Developer Documentation","title":"Adding New Root-Finding Methods","text":"To add a new root-finding method, you need to:\n\nDefine the method struct:\n\nstruct MyNewMethod{FT} <: RootSolvingMethod{FT}\n    x0::FT\n    # Add other fields as needed\nend\n\nImplement method_args:\n\nmethod_args(method::MyNewMethod) = (method.x0,)\n\nImplement the main find_zero method:\n\nfunction find_zero(\n    f::F,\n    ::MyNewMethod,\n    x0::FT,\n    soltype::SolutionType,\n    tol::AbstractTolerance,\n    maxiters::Int,\n) where {F <: Function, FT}\n    # Your implementation here\n    return _find_zero_my_method(f, x0, soltype, tol, maxiters)\nend\n\nImplement the core algorithm:\n\nfunction _find_zero_my_method(f, x0, soltype, tol, maxiters)\n    # Your root-finding algorithm implementation\n    # Return a SolutionResults object\nend","category":"section"},{"location":"DeveloperDocs/#Adding-New-Tolerance-Types","page":"Developer Documentation","title":"Adding New Tolerance Types","text":"To add a new tolerance type:\n\nDefine the tolerance struct:\n\nstruct MyTolerance{FT} <: AbstractTolerance{FT}\n    tol::FT\nend\n\nImplement the callable interface:\n\n(tol::MyTolerance)(x1, x2, y) = # your convergence criterion","category":"section"},{"location":"DeveloperDocs/#Adding-New-Solution-Types","page":"Developer Documentation","title":"Adding New Solution Types","text":"To add a new solution type:\n\nDefine the solution type:\n\nstruct MySolution <: SolutionType end\n\nDefine the results struct:\n\nstruct MySolutionResults{FT} <: AbstractSolutionResults{FT}\n    root::FT\n    converged::Bool\n    # Add other fields as needed\nend\n\nImplement the constructor:\n\nSolutionResults(soltype::MySolution, args...) = MySolutionResults(args...)\n\nImplement history functions:\n\ninit_history(::MySolution, x::FT) where {FT <: Real} = # your initialization\npush_history!(history, x, ::MySolution) = # your push logic","category":"section"},{"location":"DeveloperDocs/#Performance-Considerations","page":"Developer Documentation","title":"Performance Considerations","text":"","category":"section"},{"location":"DeveloperDocs/#GPU-Compatibility","page":"Developer Documentation","title":"GPU Compatibility","text":"When extending RootSolvers.jl for GPU compatibility:\n\nUse ifelse instead of if-else blocks where possible\nAvoid dynamic dispatch in hot loops\nEnsure all functions are type-stable\nUse CompactSolution for GPU operations (avoid VerboseSolution)","category":"section"},{"location":"DeveloperDocs/#Memory-Management","page":"Developer Documentation","title":"Memory Management","text":"CompactSolution is memory-efficient and GPU-compatible\nVerboseSolution stores iteration history and is CPU-only\nConsider memory usage when implementing new solution types","category":"section"},{"location":"DeveloperDocs/#Type-Stability","page":"Developer Documentation","title":"Type Stability","text":"Ensure all functions return consistent types\nUse Base.Fix1 for function composition instead of anonymous functions\nAvoid type instability in hot loops","category":"section"},{"location":"DeveloperDocs/#Testing-Guidelines","page":"Developer Documentation","title":"Testing Guidelines","text":"","category":"section"},{"location":"DeveloperDocs/#Test-Structure","page":"Developer Documentation","title":"Test Structure","text":"The tests are located in the test/ directory:\n\ntest/runtests.jl: Main test suite with comprehensive tests for all methods (including GPU tests)\ntest/test_helper.jl: Helper functions and test utilities\ntest/test_printing.jl: Tests for solution printing and formatting","category":"section"},{"location":"DeveloperDocs/#What-Tests-Cover","page":"Developer Documentation","title":"What Tests Cover","text":"","category":"section"},{"location":"DeveloperDocs/#test/runtests.jl","page":"Developer Documentation","title":"test/runtests.jl","text":"All root-finding methods: Secant, Regula Falsi, Brent's, Newton's (AD and manual)\nAll tolerance types: Solution, Residual, Relative, and combined tolerances\nAll solution types: Compact and Verbose solutions\nEdge cases: Non-finite inputs, convergence failures, high-multiplicity roots\nBroadcasting: Array and GPU compatibility\nType stability: Different floating-point types (Float32, Float64)","category":"section"},{"location":"DeveloperDocs/#GPU-Tests-(integrated-in-test/runtests.jl)","page":"Developer Documentation","title":"GPU Tests (integrated in test/runtests.jl)","text":"GPU kernel tests: CUDA array compatibility\nBroadcasting on GPU: Parallel root-finding on GPU arrays","category":"section"},{"location":"DeveloperDocs/#test/test_helper.jl","page":"Developer Documentation","title":"test/test_helper.jl","text":"Test utilities: Helper functions for generating test problems\nMethod type definitions: Test-specific method types\nProblem generators: Functions to create test cases","category":"section"},{"location":"DeveloperDocs/#test/test_printing.jl","page":"Developer Documentation","title":"test/test_printing.jl","text":"Solution formatting: Compact and verbose solution display\nColor output: Terminal color coding for convergence status\nHistory display: Iteration history formatting","category":"section"},{"location":"DeveloperDocs/#Running-Tests","page":"Developer Documentation","title":"Running Tests","text":"","category":"section"},{"location":"DeveloperDocs/#Basic-Test-Suite","page":"Developer Documentation","title":"Basic Test Suite","text":"# From the project root\njulia --project=. -e \"using Pkg; Pkg.test()\"\n\n# Or using the test script directly\njulia --project=. test/runtests.jl","category":"section"},{"location":"DeveloperDocs/#Specific-Test-Files","page":"Developer Documentation","title":"Specific Test Files","text":"# Run the main test suite (CPU only)\njulia --project=. test/runtests.jl\n\n# Run tests with GPU arrays (requires CUDA.jl and compatible GPU)\njulia --project=. test/runtests.jl CuArray\n\n# Run printing tests\njulia --project=. test/test_printing.jl","category":"section"},{"location":"DeveloperDocs/#GPU-Tests","page":"Developer Documentation","title":"GPU Tests","text":"# Run all tests including GPU tests (only run when CUDA.jl and compatible GPU is available)\njulia --project=. test/runtests.jl CuArray","category":"section"},{"location":"DeveloperDocs/#Test-Coverage","page":"Developer Documentation","title":"Test Coverage","text":"The test suite aims for comprehensive coverage:\n\nUnit tests: Test individual functions and methods\nGPU tests: Test CUDA compatibility and performance (integrated in main test suite)\nEdge case tests: Handle difficult convergence scenarios\nType stability tests: Ensure GPU compatibility\nBroadcasting tests: Test array and GPU operations","category":"section"},{"location":"DeveloperDocs/#Continuous-Integration","page":"Developer Documentation","title":"Continuous Integration","text":"Tests are automatically run on:\n\nGitHub Actions: Multiple Julia versions and operating systems\nCode coverage: Tracked via CodeCov\nGPU tests: Run on CUDA-compatible runners","category":"section"},{"location":"DeveloperDocs/#RootSolvers.method_args","page":"Developer Documentation","title":"RootSolvers.method_args","text":"method_args(method::RootSolvingMethod)\n\nExtract the initial guess(es) for a root-solving method for internal dispatch.\n\nThis function is used internally to unpack method parameters for passing to the appropriate find_zero implementation.\n\nArguments\n\nmethod::RootSolvingMethod: The root-solving method instance\n\nReturns\n\nTuple: Initial guess(es) specific to the method type\n\nExample\n\nmethod = SecantMethod{Float64}(0.0, 1.0)\nargs = method_args(method)  # Returns (0.0, 1.0)\n\n\n\n\n\n","category":"function"},{"location":"DeveloperDocs/#RootSolvers.value_deriv","page":"Developer Documentation","title":"RootSolvers.value_deriv","text":"value_deriv(f, x)\n\nCompute both the function value and its derivative at point x using automatic differentiation.\n\nThis function uses ForwardDiff.jl to simultaneously compute f(x) and f'(x), which is more efficient than computing them separately when both are needed (as in Newton's method). It is used internally by NewtonsMethodAD.\n\nArguments\n\nf: Function to evaluate\nx::FT: Point at which to evaluate the function and derivative\n\nReturns\n\nTuple{FT, FT}: (f(x), f'(x)) where the second element is the derivative\n\nExample\n\nf(x) = x^3 - 2x + 1\nval, deriv = value_deriv(f, 1.5)\n# val ‚âà 1.375, deriv ‚âà 4.75\n\n\n\n\n\n","category":"function"},{"location":"DeveloperDocs/#RootSolvers.default_tol","page":"Developer Documentation","title":"RootSolvers.default_tol","text":"default_tol(FT)\n\nReturns the default tolerance for a given type FT. This is a helper function to provide a consistent default tolerance for different numerical types.\n\nArguments\n\nFT: The type of the numerical value (e.g., Float64, ComplexF64).\n\nReturns\n\nAbstractTolerance: A default tolerance object.\n\nExample\n\nusing RootSolvers\n\n# Find the default tolerance for Float64\ntol = default_tol(Float64)\nprintln(\"Default tolerance for Float64: \", tol)\n# Default tolerance for Float64: SolutionTolerance{Float64}(1e-4)\n\n\n\n\n\n","category":"function"},{"location":"DeveloperDocs/#RootSolvers.RootSolvingMethod","page":"Developer Documentation","title":"RootSolvers.RootSolvingMethod","text":"RootSolvingMethod{FT} <: AbstractType\n\nAbstract type for root-finding methods in RootSolvers.jl.\n\nThis is the base type for all numerical methods used to find roots of scalar functions. Each concrete method type should implement the method_args function to extract initial guesses and parameters for the solver.\n\nType Parameters\n\nFT: The floating-point type for computations (e.g., Float64, Float32)\n\nConcrete Implementations\n\nSecantMethod{FT}: Linear interpolation between two points\nRegulaFalsiMethod{FT}: Bracketing method with linear interpolation\nBisectionMethod{FT}: Simple bracketing method with guaranteed convergence\nBrentsMethod{FT}: Robust bracketing method combining multiple techniques\nNewtonsMethodAD{FT}: Newton's method with automatic differentiation\nNewtonsMethod{FT}: Newton's method with user-provided derivatives\n\nInterface Requirements\n\nAll concrete subtypes must implement:\n\nmethod_args(method): Return initial guesses as a tuple\nfind_zero(f, method, args..., soltype, tol, maxiters): Main solver implementation\n\nExample\n\n# Define a custom method\nstruct MyCustomMethod{FT} <: RootSolvingMethod{FT}\n    x0::FT\nend\n\n# Implement required interface\nmethod_args(method::MyCustomMethod) = (method.x0,)\n\n# Use with find_zero\nsol = find_zero(x -> x^2 - 4, MyCustomMethod{Float64}(1.0))\n\n\n\n\n\n","category":"type"},{"location":"DeveloperDocs/#RootSolvers.SolutionType","page":"Developer Documentation","title":"RootSolvers.SolutionType","text":"SolutionType <: AbstractType\n\nAbstract type for solution formats in RootSolvers.jl.\n\nThis is the base type for all solution types that control the level of detail returned by find_zero. Each concrete solution type should implement the SolutionResults constructor and history management functions.\n\nConcrete Implementations\n\nCompactSolution: Memory-efficient, GPU-compatible solution with minimal output\nVerboseSolution: CPU-only solution with detailed diagnostics and iteration history\n\nInterface Requirements\n\nAll concrete subtypes must implement:\n\nSolutionResults(soltype, args...): Constructor for the corresponding results type\ninit_history(soltype, x): Initialize history storage for the solution type\npush_history!(history, x, soltype): Add a value to the history\n\nExample\n\n# Define a custom solution type\nstruct MySolution <: SolutionType end\n\n# Implement required interface\nSolutionResults(soltype::MySolution, args...) = MySolutionResults(args...)\ninit_history(::MySolution, x) = [x]\npush_history!(history, x, ::MySolution) = push!(history, x)\n\n# Use with find_zero\nsol = find_zero(x -> x^2 - 4, SecantMethod(1.0, 3.0), MySolution())\n\n\n\n\n\n","category":"type"},{"location":"#RootSolvers.jl","page":"Home","title":"RootSolvers.jl","text":"RootSolvers.jl is a Julia package for finding roots of nonlinear equations using robust, efficient, and GPU-capable numerical methods. It provides a simple, unified interface for a variety of classic root-finding algorithms, with flexible convergence criteria and solution reporting. The package supports dual numbers for automatic differentiation, making it suitable for integration into differentiable models and optimization problems.\n\nGetting Started: Installation, quick start, and how-to guide\nAPI Reference: Full documentation of all methods and types","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"See the Getting Started page for more details and examples.\n\nInstall stable release:\n\nusing Pkg\nPkg.add(\"RootSolvers\")\n\nFind a root of a quadratic equation:\n\nusing RootSolvers\n\n# Find the root of x^2 - 100^2 using the secant method\nsol = find_zero(x -> x^2 - 100^2, SecantMethod(0.0, 1000.0))\n\nOr use Brent's method for robust bracketing\n\nsol = find_zero(x -> x^2 - 100^2, BrentsMethod(-200.0, 0.0))","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"Getting Started\nAPI Reference\nDeveloper Documentation","category":"section"},{"location":"API/#API-Reference","page":"API","title":"API Reference","text":"This page provides the complete API reference for RootSolvers.jl. For a more narrative introduction, see the Getting Started guide.","category":"section"},{"location":"API/#Module-Overview","page":"API","title":"Module Overview","text":"","category":"section"},{"location":"API/#Main-Function","page":"API","title":"Main Function","text":"The primary entry point for the package is the find_zero function.\n\n","category":"section"},{"location":"API/#Numerical-Methods","page":"API","title":"Numerical Methods","text":"The following structs are used to select the root-finding algorithm.\n\nMethod Requirements Best For\nSecantMethod 2 initial guesses No derivatives, fast convergence\nRegulaFalsiMethod Bracketing interval (sign change) Guaranteed convergence\nBisectionMethod Bracketing interval (sign change) Guaranteed convergence, simple\nBrentsMethod Bracketing interval (sign change) Superlinear convergence, robust\nNewtonsMethodAD 1 initial guess, differentiable f Fastest, uses autodiff, robust step control\nNewtonsMethod 1 initial guess, f and f' provided Analytical derivatives, robust step control\n\n","category":"section"},{"location":"API/#Solution-Types","page":"API","title":"Solution Types","text":"These types control the level of detail in the output returned by find_zero.\n\nSolution Type Features Best For\nCompactSolution Minimal output, GPU-friendly High-performance, GPU, memory efficiency\nVerboseSolution Full diagnostics, iteration history Debugging, analysis, CPU\n\n","category":"section"},{"location":"API/#Tolerance-Types","page":"API","title":"Tolerance Types","text":"Tolerance types define the convergence criteria for the solver.\n\nTolerance Type Criterion Best For\nSolutionTolerance           ) abs(x‚ÇÇ - x‚ÇÅ) When you want iterates to stabilize\nResidualTolerance abs(f(x)) When you want the function value near zero\nRelativeSolutionTolerance abs((x‚ÇÇ - x‚ÇÅ)/x‚ÇÅ) When root magnitude varies widely\nRelativeOrAbsoluteSolutionTolerance Relative or Absolute Robust for both small and large roots\n\n","category":"section"},{"location":"API/#Broadcasting-and-High-Performance-Computing","page":"API","title":"Broadcasting and High-Performance Computing","text":"RootSolvers.jl is designed for high-performance computing applications and supports broadcasting to solve many problems in parallel. This is especially useful for GPU arrays or custom field types used in scientific modeling.\n\nThe custom broadcasting rule unpacks initial guesses from the method struct while treating all other arguments as scalars. This enables a clean API for batch-solving.\n\nFor more information about broadcasting, see the examples in the find_zero documentation.\n\n","category":"section"},{"location":"API/#Developer-Documentation","page":"API","title":"Developer Documentation","text":"For information about internal methods, extending RootSolvers.jl, and developer-focused functionality, see the Developer Documentation.","category":"section"},{"location":"API/#RootSolvers.RootSolvers","page":"API","title":"RootSolvers.RootSolvers","text":"RootSolvers.jl\n\nA Julia package for solving roots of non-linear equations using various numerical methods. Contains functions for finding zeros of scalar functions using robust iterative algorithms.\n\nThe main entry point is find_zero, which supports multiple root-finding methods and tolerance criteria.\n\nSupported Methods\n\nSecant Method: Requires two initial guesses, uses linear interpolation\nBisection Method: Requires bracketing interval with sign change, converges linearly\nRegula Falsi Method: Requires bracketing interval with sign change\nBrent's Method: Requires bracketing interval, combines bisection, secant, and inverse quadratic interpolation\nNewton's Method with AD: Requires one initial guess, uses automatic differentiation\nNewton's Method: Requires one initial guess and user-provided derivative\n\nMethod Selection Guide\n\nBracketing methods (Bisection, Regula Falsi, Brent's): Use when you know an interval containing the root\nBrent's method: Recommended for robust, guaranteed convergence with superlinear rate\nSecant method: Good when you have two guesses but no bracketing interval\nNewton's methods: Fastest convergence when you have a good initial guess\n\nExample\n\nusing RootSolvers\n\n# Find the square root of a quadratic equation using the secant method\nsol = find_zero(x -> x^2 - 100^2,\n               SecantMethod{Float64}(0.0, 1000.0),\n               CompactSolution());\n\nprintln(sol)\n# CompactSolutionResults{Float64}:\n# ‚îú‚îÄ‚îÄ Status: converged\n# ‚îî‚îÄ‚îÄ Root: 99.99999999994358\n\n# Access the root value\nroot_value = sol.root  # 99.99999999994358\n\n# Use Brent's method for robust convergence with bracketing interval\nsol_brent = find_zero(x -> x^3 - 8,\n                     BrentsMethod{Float64}(-1.0, 3.0),\n                     CompactSolution());\n\n# Use Newton's method with automatic differentiation for faster convergence\nsol_newton = find_zero(x -> x^3 - 27,\n                      NewtonsMethodAD{Float64}(2.0),\n                      VerboseSolution());\n\n\n\n\n\n","category":"module"},{"location":"API/#RootSolvers.find_zero","page":"API","title":"RootSolvers.find_zero","text":"find_zero(f, method, soltype=CompactSolution(), tol=nothing, maxiters=1_000)\n\nFind a root of the scalar function f using the specified numerical method.\n\nThis is the main entry point for root finding in RootSolvers.jl. Given a function f, it finds a value x such that f(x) ‚âà 0 using iterative numerical methods. The function supports various root-finding algorithms, tolerance criteria, and solution formats.\n\nArguments\n\nf::Function: The function for which to find a root. Should take a scalar input and return a scalar output.\nmethod::RootSolvingMethod: The numerical method to use. Available methods:\nBisectionMethod: Bracketing method maintaining sign change (linear convergence, guaranteed)\nSecantMethod: Uses linear interpolation between two points (superlinear convergence)\nRegulaFalsiMethod: Bracketing method maintaining sign change (linear convergence, guaranteed)\nBrentsMethod: Robust bracketing method combining bisection, secant, and inverse quadratic interpolation\nNewtonsMethodAD: Newton's method with automatic differentiation (quadratic convergence)\nNewtonsMethod: Newton's method with user-provided derivative (quadratic convergence)\nsoltype::SolutionType: Format of the returned solution (default: CompactSolution()):\nCompactSolution: Returns only root and convergence status (GPU-compatible)\nVerboseSolution: Returns detailed diagnostics and iteration history (CPU-only)\ntol::Union{Nothing, AbstractTolerance}: Convergence criterion (default: SolutionTolerance(1e-4) for Float64, 1e-3 otherwise):\nResidualTolerance: Based on |f(x)|\nSolutionTolerance: Based on |x_{n+1} - x_n|\nRelativeSolutionTolerance: Based on |(x_{n+1} - x_n)/x_n|\nRelativeOrAbsoluteSolutionTolerance: Combined relative and absolute tolerance\nmaxiters::Int: Maximum number of iterations allowed (default: 1,000)\n\nReturns\n\nAbstractSolutionResults: Solution object containing the root and convergence information. The exact type depends on the soltype parameter:\nCompactSolutionResults: Contains root and converged fields\nVerboseSolutionResults: Additionally contains err, iter_performed, and iteration history\n\nExamples\n\nusing RootSolvers\n\n# Find square root of 2 using secant method\nsol = find_zero(x -> x^2 - 2, SecantMethod{Float64}(1.0, 2.0))\nprintln(\"‚àö2 ‚âà $(sol.root)\")  # ‚àö2 ‚âà 1.4142135623730951\n\n# Use Newton's method with automatic differentiation for faster convergence\nsol = find_zero(x -> x^3 - 27, NewtonsMethodAD{Float64}(2.0))\nprintln(\"‚àõ27 = $(sol.root)\")  # ‚àõ27 = 3.0\n\n# Get detailed iteration history\nsol = find_zero(x -> exp(x) - 2, \n               NewtonsMethodAD{Float64}(0.5), \n               VerboseSolution())\nprintln(\"ln(2) ‚âà $(sol.root) found in $(sol.iter_performed) iterations\")\n\n# Use custom tolerance\ntol = RelativeOrAbsoluteSolutionTolerance(1e-12, 1e-15)\nsol = find_zero(x -> cos(x), \n               NewtonsMethodAD{Float64}(1.0), \n               CompactSolution(), \n               tol)\nprintln(\"œÄ/2 ‚âà $(sol.root)\")\n\n# Robust bracketing method for difficult functions\nsol = find_zero(x -> x^3 - 2x - 5, RegulaFalsiMethod{Float64}(2.0, 3.0))\n\nBatch and GPU Root-Finding (Broadcasting)\n\nYou can broadcast find_zero over arrays of methods or initial guesses to solve many root-finding problems in parallel, including on the GPU:\n\nusing CUDA, RootSolvers\nx0 = CUDA.fill(1.0, 1000)  # 1000 initial guesses on the GPU\nmethod = SecantMethod.(x0, x0 .+ 1)\n# f should be broadcastable over arrays\nsol = find_zero.(x -> x.^2 .- 2, method, CompactSolution())\n\nThis is especially useful for large-scale or batched root-finding on GPUs. Only CompactSolution is GPU-compatible.\n\nMethod Selection Guide\n\nBisectionMethod: Simple general-purpose bracketing method, slow but guaranteed convergence\nSecantMethod: Good general-purpose method, no derivatives needed\nRegulaFalsiMethod: Use when you need guaranteed convergence with a bracketing interval\nBrentsMethod: Robust bracketing method combining bisection, secant, and inverse quadratic interpolation\nNewtonsMethodAD: Fastest convergence when derivatives are available via autodiff\nNewtonsMethod: Use when you can provide analytical derivatives efficiently\n\nSee Also\n\nBisectionMethod, SecantMethod, RegulaFalsiMethod, BrentsMethod, NewtonsMethodAD, NewtonsMethod\nCompactSolution, VerboseSolution\nResidualTolerance, SolutionTolerance\n\n\n\n\n\n","category":"function"},{"location":"API/#RootSolvers.SecantMethod","page":"API","title":"RootSolvers.SecantMethod","text":"SecantMethod{FT} <: RootSolvingMethod{FT}\n\nThe secant method for root finding, which uses linear interpolation between two points to approximate the derivative. This method requires two initial guesses but does not require the function to be differentiable or the guesses to bracket a root.\n\nThe method uses the recurrence relation:\n\nx_n+1 = x_n - f(x_n) fracx_n - x_n-1f(x_n) - f(x_n-1)\n\nConvergence\n\nOrder: Approximately 1.618 (superlinear)\nRequirements: Two initial guesses, continuous function\nAdvantages: No derivative required, fast convergence\nDisadvantages: May not converge if initial guesses are poor\n\nFields\n\nx0::FT: First initial guess\nx1::FT: Second initial guess\n\nExample\n\nmethod = SecantMethod{Float64}(0.0, 2.0)\nsol = find_zero(x -> x^3 - 8, method)\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.RegulaFalsiMethod","page":"API","title":"RootSolvers.RegulaFalsiMethod","text":"RegulaFalsiMethod{FT} <: RootSolvingMethod{FT}\n\nThe Regula Falsi (false position) method for root finding. This is a bracketing method that maintains the sign change property and uses linear interpolation to find the root.\n\nThe method requires that f(x0) and f(x1) have opposite signs, ensuring that a root exists in the interval [x0, x1].\n\nConvergence\n\nOrder: Linear (slower than Newton's method)\nRequirements: Bracketing interval with f(x0) * f(x1) < 0\nAdvantages: Guaranteed convergence, robust\nDisadvantages: Slower convergence than other methods\n\nFields\n\nx0::FT: Lower bound of bracketing interval\nx1::FT: Upper bound of bracketing interval\n\nExample\n\n# Find root of x^3 - 2 in interval [-1, 2]\nmethod = RegulaFalsiMethod{Float64}(-1.0, 2.0)\nsol = find_zero(x -> x^3 - 2, method)\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.BisectionMethod","page":"API","title":"RootSolvers.BisectionMethod","text":"BisectionMethod{FT} <: RootSolvingMethod{FT}\n\nThe bisection method for root finding. This is a simple bracketing method that divides the interval in half at each iteration. The method requires that f(x0) and f(x1) have opposite signs, ensuring that a root exists in the interval [x0, x1].\n\nThe method uses the recurrence relation:\n\nx_n+1 = fracx_0 + x_12\n\nwhere the interval [x0, x1] is updated based on the sign of f(x_{n+1}).\n\nConvergence\n\nOrder: Linear (slower than Newton's method)\nRequirements: Bracketing interval with f(x0) * f(x1) < 0\nAdvantages: Guaranteed convergence, simple implementation\nDisadvantages: Slower convergence than other methods\n\nFields\n\nx0::FT: Lower bound of bracketing interval\nx1::FT: Upper bound of bracketing interval\n\nExample\n\n# Find root of x^3 - 2 in interval [-1, 2]\nmethod = BisectionMethod{Float64}(-1.0, 2.0)\nsol = find_zero(x -> x^3 - 2, method)\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.BrentsMethod","page":"API","title":"RootSolvers.BrentsMethod","text":"BrentsMethod{FT} <: RootSolvingMethod{FT}\n\nBrent's method for root finding, which combines the bisection method, secant method, and inverse quadratic interpolation. This is a bracketing method that maintains the sign change property and provides superlinear convergence.\n\nThe method requires that f(x0) and f(x1) have opposite signs, ensuring that a root exists in the interval [x0, x1].\n\nConvergence\n\nOrder: Superlinear (faster than Regula Falsi)\nRequirements: Bracketing interval with f(x0) * f(x1) < 0\nAdvantages: Guaranteed convergence, fast convergence, robust\nDisadvantages: More complex than simpler bracketing methods\n\nFields\n\nx0::FT: Lower bound of bracketing interval\nx1::FT: Upper bound of bracketing interval\n\nExample\n\n# Find root of x^3 - 2 in interval [-1, 2]\nmethod = BrentsMethod{Float64}(-1.0, 2.0)\nsol = find_zero(x -> x^3 - 2, method)\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.NewtonsMethodAD","page":"API","title":"RootSolvers.NewtonsMethodAD","text":"NewtonsMethodAD{FT} <: RootSolvingMethod{FT}\n\nNewton's method for root finding using automatic differentiation to compute derivatives. This method provides quadratic convergence when close to the root and the derivative is non-zero. The implementation includes step size limiting and backtracking line search for robustness.\n\nThe method uses the iteration\n\nx_n+1 = x_n - fracf(x_n)f(x_n)\n\nwhere the derivative f'(x_n) is computed using ForwardDiff.jl.\n\nConvergence\n\nOrder: Quadratic (very fast near the root)\nRequirements: Differentiable function, good initial guess\nAdvantages: Fast convergence, automatic derivative computation, robust step size control\nDisadvantages: May not converge if initial guess is poor or derivative is zero\n\nFields\n\nx0::FT: Initial guess for the root\n\nExample\n\n# Find cube root of 27\nmethod = NewtonsMethodAD{Float64}(2.0)\nsol = find_zero(x -> x^3 - 27, method)\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.NewtonsMethod","page":"API","title":"RootSolvers.NewtonsMethod","text":"NewtonsMethod{FT} <: RootSolvingMethod{FT}\n\nNewton's method for root finding where the user provides both the function and its derivative. This method provides quadratic convergence when close to the root. The implementation includes step size limiting and backtracking line search for robustness.\n\nThe method uses the iteration\n\nx_n+1 = x_n - fracf(x_n)f(x_n)\n\nConvergence\n\nOrder: Quadratic (very fast near the root)\nRequirements: Function and derivative, good initial guess\nAdvantages: Fast convergence, no automatic differentiation overhead, robust step size control\nDisadvantages: Requires manual derivative computation\n\nFields\n\nx0::FT: Initial guess for the root\n\nNote\n\nWhen using this method, your function f should return a tuple (f(x), f'(x)) containing both the function value and its derivative at x.\n\nExample\n\n# Find root of x^2 - 4, providing both function and derivative\nf_and_df(x) = (x^2 - 4, 2x)\nmethod = NewtonsMethod{Float64}(1.0)\nsol = find_zero(f_and_df, method)\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.CompactSolution","page":"API","title":"RootSolvers.CompactSolution","text":"CompactSolution <: SolutionType\n\nA memory-efficient solution type that returns only essential information about the root.\n\nWhen used with find_zero, returns a CompactSolutionResults object containing only the root value and convergence status. This solution type is GPU-compatible and suitable for high-performance applications where memory usage is critical.\n\nAccessing Results\n\nThe returned CompactSolutionResults object contains the following fields:\n\nsol.root: The found root value\nsol.converged: Boolean indicating if the method converged\n\nExample\n\nsol = find_zero(x -> x^2 - 4, \n               SecantMethod{Float64}(0.0, 3.0), \n               CompactSolution())\n\n# Access the root\nprintln(\"Root: $(sol.root)\")\n\n# Check convergence\nif sol.converged\n    println(\"Root found successfully!\")\nelse\n    println(\"Method failed to converge\")\nend\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.VerboseSolution","page":"API","title":"RootSolvers.VerboseSolution","text":"VerboseSolution <: SolutionType\n\nA solution type that returns detailed information about the root-finding process, including iteration history and convergence diagnostics.\n\nWhen used with find_zero, returns a VerboseSolutionResults object containing the root, convergence status, error information, and complete iteration history.\n\nAccessing Results\n\nThe returned VerboseSolutionResults object contains the following fields:\n\nsol.root: The found root value\nsol.converged: Boolean indicating if the method converged\nsol.err: Final error value (function value at the root)\nsol.iter_performed: Number of iterations performed\nsol.root_history: Vector of all root values during iteration\nsol.err_history: Vector of all error values during iteration\n\nNote\n\nThis solution type stores iteration history and is primarily intended for CPU computations. For GPU computations or when memory usage is a concern, use CompactSolution instead.\n\nExample\n\nsol = find_zero(x -> x^2 - 4, SecantMethod(1.0, 3.0), VerboseSolution())\n\n# Access the root\nroot_value = sol.root\n\n# Check convergence and diagnostics\nif sol.converged\n    println(\"Root found: \", root_value)\n    println(\"Converged in \", sol.iter_performed, \" iterations\")\n    println(\"Final error: \", sol.err)\nelse\n    println(\"Method failed to converge\")\nend\n\n# Access iteration history\nprintln(\"First iteration root: \", sol.root_history[1])\nprintln(\"Last iteration root: \", sol.root_history[end])\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.AbstractTolerance","page":"API","title":"RootSolvers.AbstractTolerance","text":"AbstractTolerance{FT} <: AbstractType\n\nAbstract type for tolerance criteria in RootSolvers.jl.\n\nThis is the base type for all tolerance types that define convergence criteria for root-finding algorithms. Each concrete tolerance type should implement the callable interface (tol)(x1, x2, y) for convergence checking.\n\nType Parameters\n\nFT: The floating-point type for tolerance values (e.g., Float64, Float32)\n\nConcrete Implementations\n\nResidualTolerance{FT}: Based on |f(x)|\nSolutionTolerance{FT}: Based on |x_{n+1} - x_n|\nRelativeSolutionTolerance{FT}: Based on |(x_{n+1} - x_n)/x_n|\nRelativeOrAbsoluteSolutionTolerance{FT}: Combined relative and absolute tolerance\n\nInterface Requirements\n\nAll concrete subtypes must implement:\n\n(tol)(x1, x2, y): Check convergence using three arguments (previous iterate, current iterate, function value)\n\nExample\n\n# Define a custom tolerance type\nstruct MyTolerance{FT} <: AbstractTolerance{FT}\n    threshold::FT\nend\n\n# Implement the required interface\n(tol::MyTolerance)(x1, x2, y) = abs(x2 - x1) < tol.threshold || abs(y) < eps(typeof(y))\n\n# Use with find_zero\nsol = find_zero(x -> x^2 - 4, SecantMethod(1.0, 3.0), CompactSolution(), MyTolerance(1e-6))\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.SolutionTolerance","page":"API","title":"RootSolvers.SolutionTolerance","text":"SolutionTolerance{FT}\n\nA convergence criterion based on the absolute difference between consecutive iterates. The iteration stops when |x_{n+1} - x_n| < tol, where tol is the specified tolerance. Convergence is also triggered if |f(x)| is smaller than the machine epsilon for the value type.\n\nThis tolerance is appropriate when you want to ensure that consecutive iterates are sufficiently close, indicating that the solution has stabilized.\n\nFields\n\ntol::FT: Tolerance threshold for |x_{n+1} - x_n|\n\nExample\n\ntol = SolutionTolerance(1e-8)\nsol = find_zero(x -> x^3 - 8, \n               SecantMethod{Float64}(1.0, 3.0),\n               CompactSolution(),\n               tol)\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.ResidualTolerance","page":"API","title":"RootSolvers.ResidualTolerance","text":"ResidualTolerance{FT}\n\nA convergence criterion based on the absolute value of the residual (function value). The iteration stops when |f(x)| < tol, where tol is the specified tolerance (limited to  the machine epsilon of the function value type).\n\nThis tolerance is appropriate when you want to ensure that the function value is sufficiently close to zero, regardless of how close consecutive iterates are.\n\nFields\n\ntol::FT: Tolerance threshold for |f(x)|\n\nExample\n\ntol = ResidualTolerance(1e-10)\nsol = find_zero(x -> x^2 - 4, \n               NewtonsMethodAD{Float64}(1.0),\n               CompactSolution(),\n               tol)\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.RelativeSolutionTolerance","page":"API","title":"RootSolvers.RelativeSolutionTolerance","text":"RelativeSolutionTolerance{FT}\n\nA convergence criterion based on the relative difference between consecutive iterates. The iteration stops when |(x_{n+1} - x_n)/x_n| < tol, where tol is the specified tolerance.  Convergence is also triggered if |f(x)| is smaller than the machine epsilon for the value type.\n\nThis tolerance is appropriate when you want to convergence relative to the magnitude of the solution, which is useful when the root value might be very large or very small.\n\nFields\n\ntol::FT: Relative tolerance threshold\n\nWarning\n\nThis tolerance criterion can fail if x_n ‚âà 0 during iteration, as it involves division by x_n. Consider using RelativeOrAbsoluteSolutionTolerance for more robust behavior.\n\nExample\n\ntol = RelativeSolutionTolerance(1e-6)\nsol = find_zero(x -> x^2 - 1e6, \n               NewtonsMethodAD{Float64}(500.0),\n               CompactSolution(),\n               tol)\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.RelativeOrAbsoluteSolutionTolerance","page":"API","title":"RootSolvers.RelativeOrAbsoluteSolutionTolerance","text":"RelativeOrAbsoluteSolutionTolerance{FT}\n\nA robust convergence criterion combining both relative and absolute tolerances. The iteration stops when either |(x_{n+1} - x_n)/x_n| < rtol OR |x_{n+1} - x_n| < atol.\n\nThis tolerance provides robust behavior across different scales of root values:\n\nThe relative tolerance rtol ensures accuracy for large roots\nThe absolute tolerance atol ensures convergence when the root is near zero\n\nFields\n\nrtol::FT: Relative tolerance threshold\natol::FT: Absolute tolerance threshold\n\nExample\n\n# Use relative tolerance of 1e-6 and absolute tolerance of 1e-10\ntol = RelativeOrAbsoluteSolutionTolerance(1e-6, 1e-10)\nsol = find_zero(x -> x^2 - 1e-8, \n               NewtonsMethodAD{Float64}(1e-3),\n               CompactSolution(),\n               tol)\n\n\n\n\n\n","category":"type"}]
}
