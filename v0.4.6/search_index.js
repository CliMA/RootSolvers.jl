var documenterSearchIndex = {"docs":
[{"location":"GettingStarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"RootSolvers.jl is a Julia package for finding roots of nonlinear equations using robust, efficient, and GPU-capable numerical methods. It provides a simple, unified interface for a variety of classic root-finding algorithms, with flexible convergence criteria and solution reporting.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"GettingStarted/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The package is registered in the Julia General registry.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Stable Release:","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"RootSolvers\")","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"GettingStarted/#Quick-Start-Example","page":"Getting Started","title":"Quick Start Example","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"using RootSolvers\n# Find the root of x^2 - 100^2 using the secant method\nsol = find_zero(x -> x^2 - 100^2, SecantMethod(0.0, 1000.0))\nsol","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The numerical value of the root is contained in sol.root:","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"sol.root","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"GettingStarted/#How-to-Guide","page":"Getting Started","title":"How-to Guide","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This guide shows the basic steps for solving a root-finding problem.","category":"page"},{"location":"GettingStarted/#General-Workflow","page":"Getting Started","title":"General Workflow","text":"","category":"section"},{"location":"GettingStarted/#1.-Define-Your-Function","page":"Getting Started","title":"1. Define Your Function","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Write your function as a Julia callable.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"f(x) = x^3 - 2x - 5\nnothing # hide","category":"page"},{"location":"GettingStarted/#2.-Choose-a-Root-Finding-Method","page":"Getting Started","title":"2. Choose a Root-Finding Method","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Pick a method and provide initial guesses. The type parameter (e.g., Float64) is often inferred automatically.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"# For SecantMethod, provide two initial guesses\nmethod = SecantMethod(1.0, 3.0)\nnothing # hide","category":"page"},{"location":"GettingStarted/#3.-(Optional)-Set-Tolerance-and-Solution-Type","page":"Getting Started","title":"3. (Optional) Set Tolerance and Solution Type","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Customize the convergence criteria and the level of detail in the output.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"# Stop when iterates are closer than 1e-6\ntol = SolutionTolerance(1e-6)\n\n# Request detailed output for debugging\nsoltype = VerboseSolution()\nnothing # hide","category":"page"},{"location":"GettingStarted/#4.-Call-find_zero","page":"Getting Started","title":"4. Call find_zero","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"All arguments after method are optional.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"sol = find_zero(f, method, soltype, tol)","category":"page"},{"location":"GettingStarted/#5.-Interpret-Results","page":"Getting Started","title":"5. Interpret Results","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"sol.converged: true if a root was found.\nsol.root: The root value.\nsol.err, sol.iter_performed, sol.root_history (available with VerboseSolution).","category":"page"},{"location":"GettingStarted/#Specific-Example:-Newton's-Method-with-a-Provided-Derivative","page":"Getting Started","title":"Specific Example: Newton's Method with a Provided Derivative","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"When using NewtonsMethod, you must provide a function that returns both the value f(x) and its derivative f'(x) as a tuple. This avoids the overhead of automatic differentiation and is highly efficient if you can provide an analytical derivative.","category":"page"},{"location":"GettingStarted/#1.-Define-Function-and-Derivative","page":"Getting Started","title":"1. Define Function and Derivative","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"# This function finds the root of f(x) = x^2 - 4.\n# It returns the tuple (f(x), f'(x)).\nf_with_deriv(x) = (x^2 - 4, 2x)\nnothing # hide","category":"page"},{"location":"GettingStarted/#2.-Choose-the-Method-and-Call-find_zero","page":"Getting Started","title":"2. Choose the Method and Call find_zero","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"# Provide a single initial guess for Newton's method\nmethod = NewtonsMethod(1.0)\n\n# The function f_with_deriv is passed to find_zero\nsol = find_zero(f_with_deriv, method)","category":"page"},{"location":"GettingStarted/#Specific-Example:-Brent's-Method-for-Robust-Root-Finding","page":"Getting Started","title":"Specific Example: Brent's Method for Robust Root Finding","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Brent's method combines the bisection method, secant method, and inverse quadratic interpolation. It provides superlinear convergence while maintaining the robustness of bracketing methods.","category":"page"},{"location":"GettingStarted/#1.-Define-Your-Function-2","page":"Getting Started","title":"1. Define Your Function","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"# This function finds the root of f(x) = x^3 - 2.\nf(x) = x^3 - 2\nnothing # hide","category":"page"},{"location":"GettingStarted/#2.-Choose-the-Method-and-Call-find_zero-2","page":"Getting Started","title":"2. Choose the Method and Call find_zero","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"# Provide a bracketing interval where f(x0) and f(x1) have opposite signs\nmethod = BrentsMethod(-1.0, 2.0)  # f(-1) = -3, f(2) = 6\n\n# Solve the root-finding problem\nsol = find_zero(f, method)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"GettingStarted/#Automatic-Differentiation-and-Dual-Number-Support","page":"Getting Started","title":"Automatic Differentiation and Dual Number Support 🔄","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"RootSolvers.jl is fully compatible with automatic differentiation frameworks, making it suitable for integration into differentiable models and optimization problems. The package supports dual numbers (from ForwardDiff.jl and other AD packages) as input arguments, allowing gradients to flow through root-finding computations. Dual number support works on GPU arrays when using compatible AD frameworks.","category":"page"},{"location":"GettingStarted/#Using-RootSolvers-in-Differentiable-Models","page":"Getting Started","title":"Using RootSolvers in Differentiable Models","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"When your function f(x) accepts dual numbers, RootSolvers.jl can be used within larger differentiable computations:","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"using RootSolvers, ForwardDiff\n\n# Define a function that works with dual numbers\nf(x) = x^3 - 2x - 5\n\n# Create a wrapper that uses root finding\nfunction solve_and_evaluate(θ)\n    # θ is a parameter that affects the root-finding problem\n    g(x) = x^3 - θ * x - 5\n    sol = find_zero(g, SecantMethod(1.0, 3.0))\n    return sol.root\nend\n\n# Compute the derivative with respect to θ\nθ = 2.0\nderiv = ForwardDiff.derivative(solve_and_evaluate, θ)\nprintln(\"Derivative: \", deriv)","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"This enables integration, for example, with optimization, when an objective function may include a root finding problem. ","category":"page"},{"location":"GettingStarted/#High-Performance-and-GPU-Computing","page":"Getting Started","title":"High-Performance and GPU Computing 🚀","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"RootSolvers.jl is designed for high-performance computing, supporting broadcasting over custom data structures and GPU acceleration. This makes it ideal for solving many problems in parallel.","category":"page"},{"location":"GettingStarted/#Broadcasting-with-Abstract-Types","page":"Getting Started","title":"Broadcasting with Abstract Types","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"The package works seamlessly with any abstract type that supports broadcasting, making it well-suited for scientific domains like climate modeling.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Example: Solving over a custom field type","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"using RootSolvers\n\n# Example using regular arrays to represent a field grid\nx0 = rand(10, 10)  # A 10x10 field of initial guesses\nx1 = x0 .+ 1       # A second field of initial guesses\n\n# Define a function that operates element-wise on the field\nf(x) = x^2 - 2\n\n# Solve the root-finding problem across the entire field\nmethod = SecantMethod(x0, x1)\nsol = find_zero.(f, method, CompactSolution()) # sol is an Array of structs","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Use getproperty.() to extract the fields from each struct in the array:","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"converged_field = getproperty.(sol, :converged)\nroot_field = getproperty.(sol, :root)\n\nprintln(\"All converged: \", all(converged_field))\nprintln(\"Root field shape: \", size(root_field))","category":"page"},{"location":"GettingStarted/#GPU-Acceleration-for-Batch-Processing","page":"Getting Started","title":"GPU Acceleration for Batch Processing","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"You can achieve significant speedups by running large batches of problems on a GPU.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"note: GPU Backends\nThe following examples use 'CUDA.jl`, but similar results\ncan be achieved for different GPU backends with KernelAbstractions.jl.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"GPU Usage Tips:","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"UseCompactSolution: Only CompactSolution is GPU-friendly. VerboseSolution is for CPU debugging only.\nGPU-Compatible Function: Ensure your function f(x) uses only GPU-supported operations.\nMinimize Data Transfer: Keep initial guesses and results on the GPU.","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Broadcasting Example: 1 Million problems on the GPU","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"using RootSolvers, CUDA\n\n# Create GPU arrays for batch processing\nx0 = CUDA.fill(1.0f0, 1000, 1000)  # 1M initial guesses on GPU\nx1 = CUDA.fill(2.0f0, 1000, 1000)  # Second initial guesses\n\n# Define GPU-compatible function\nf(x) = x^3 - x - 2\n\n# Solve all problems in parallel using broadcasting\nmethod = SecantMethod(x0, x1) # method = SecantMethod.(x0, x1) is also supported\nsol = find_zero.(f, method, CompactSolution()) # broadcast launches kernel\n\n# Results are on the GPU as an array of CompactSolutions\nconverged_field = map(sol_i -> sol_i.converged, sol)\nroot_field = map(sol_i -> sol_i.root, sol)\n\nprintln(\"All converged: \", all(converged_field)) # Ouput: \"All converged: true\"\nprintln(\"Root field shape: \", size(root_field)) # Output \"Root field shape: (1000, 1000)\"","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Map Example: 1 Million problems on the GPU","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"using RootSolvers, CUDA\n\n# Create GPU arrays for batch processing\nx0 = CUDA.fill(1.0f0, 1000, 1000)  # 1M initial guesses on GPU\nx1 = CUDA.fill(2.0f0, 1000, 1000)  # Second initial guesses\n\n# Define GPU-compatible function\nf(x) = x^3 - x - 2\n\n# Solve all problems in parallel using map\nconst METHOD = SecantMethod\nsol = map(x0, x1) do x0, x1 # map launches kernel\n    find_zero(f, METHOD(x0, x1), CompactSolution())\nend\n\n# Results are on the GPU as an array of CompactSolutions\nconverged_field = map(sol_i -> sol_i.converged, sol)\nroot_field = map(sol_i -> sol_i.root, sol)\n\nprintln(\"All converged: \", all(converged_field)) # Ouput: \"All converged: true\"\nprintln(\"Root field shape: \", size(root_field)) # Output \"Root field shape: (1000, 1000)\"","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"GettingStarted/#Reference-Tables","page":"Getting Started","title":"Reference Tables","text":"","category":"section"},{"location":"GettingStarted/#Available-Root-Finding-Methods","page":"Getting Started","title":"Available Root-Finding Methods","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Method Requirements Best For\nSecantMethod 2 initial guesses No derivatives, fast convergence\nRegulaFalsiMethod Bracketing interval Guaranteed convergence\nBisectionMethod Bracketing interval Guaranteed convergence, simple\nBrentsMethod Bracketing interval Superlinear convergence, robust\nNewtonsMethodAD 1 initial guess, differentiable f Fastest, uses autodiff, robust step control\nNewtonsMethod 1 initial guess, f and f' provided Analytical derivatives, robust step control","category":"page"},{"location":"GettingStarted/#Available-Tolerance-Types","page":"Getting Started","title":"Available Tolerance Types","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Tolerance Type Criterion Best For\nSolutionTolerance abs(x₂ - x₁) When you want iterates to stabilize\nResidualTolerance abs(f(x)) When you want the function value near zero\nRelativeSolutionTolerance abs((x₂ - x₁)/x₁) When root magnitude varies widely\nRelativeOrAbsolute... Relative or Absolute Robust for both small and large roots","category":"page"},{"location":"GettingStarted/#Available-Solution-Types","page":"Getting Started","title":"Available Solution Types","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Solution Type Features Best For\nCompactSolution Minimal output, GPU-friendly High-performance, GPU, memory efficiency\nVerboseSolution Full diagnostics, iteration history Debugging, analysis, CPU","category":"page"},{"location":"GettingStarted/#Advanced-Features","page":"Getting Started","title":"Advanced Features","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"Feature Description Use Cases\nDual Number Support Compatible with automatic differentiation Differentiable models, optimization, gradient-based learning\nGPU Acceleration Full CUDA.jl support with broadcasting Large-scale parallel processing, batch computations\nCustom Field Types Works with any broadcastable type Scientific computing, climate modeling, custom data structures","category":"page"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"GettingStarted/#Troubleshooting","page":"Getting Started","title":"Troubleshooting","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"If not converging, try different initial guesses or a bracketing method such as BrentsMethod.\nUse VerboseSolution() to inspect the iteration history and diagnose issues.\nAdjust the tolerance for stricter or looser convergence criteria.","category":"page"},{"location":"GettingStarted/#Extending-RootSolvers.jl","page":"Getting Started","title":"Extending RootSolvers.jl","text":"","category":"section"},{"location":"GettingStarted/","page":"Getting Started","title":"Getting Started","text":"If you want to add custom root-finding methods, tolerance types, or solution formats, see the Developer Documentation for detailed guidance on extending the package.","category":"page"},{"location":"DeveloperDocs/#Developer-Documentation","page":"Developer Documentation","title":"Developer Documentation","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"This section contains documentation for internal methods and developer-focused functionality that may be useful for advanced development and extending RootSolvers.jl.","category":"page"},{"location":"DeveloperDocs/#Internal-Methods","page":"Developer Documentation","title":"Internal Methods","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"These functions are used internally by the solvers but are exported and may be useful for advanced development.","category":"page"},{"location":"DeveloperDocs/#RootSolvers.method_args","page":"Developer Documentation","title":"RootSolvers.method_args","text":"method_args(method::RootSolvingMethod)\n\nExtract the initial guess(es) for a root-solving method for internal dispatch.\n\nThis function is used internally to unpack method parameters for passing to the appropriate find_zero implementation.\n\nArguments\n\nmethod::RootSolvingMethod: The root-solving method instance\n\nReturns\n\nTuple: Initial guess(es) specific to the method type\n\nExample\n\nmethod = SecantMethod{Float64}(0.0, 1.0)\nargs = method_args(method)  # Returns (0.0, 1.0)\n\n\n\n\n\n","category":"function"},{"location":"DeveloperDocs/#RootSolvers.value_deriv","page":"Developer Documentation","title":"RootSolvers.value_deriv","text":"value_deriv(f, x)\n\nCompute both the function value and its derivative at point x using automatic differentiation.\n\nThis function uses ForwardDiff.jl to simultaneously compute f(x) and f'(x), which is more efficient than computing them separately when both are needed (as in Newton's method). It is used internally by NewtonsMethodAD.\n\nArguments\n\nf: Function to evaluate\nx::FT: Point at which to evaluate the function and derivative\n\nReturns\n\nTuple{FT, FT}: (f(x), f'(x)) where the second element is the derivative\n\nExample\n\nf(x) = x^3 - 2x + 1\nval, deriv = value_deriv(f, 1.5)\n# val ≈ 1.375, deriv ≈ 4.75\n\n\n\n\n\n","category":"function"},{"location":"DeveloperDocs/#RootSolvers.default_tol","page":"Developer Documentation","title":"RootSolvers.default_tol","text":"default_tol(FT)\n\nReturns the default tolerance for a given type FT. This is a helper function to provide a consistent default tolerance for different numerical types.\n\nArguments\n\nFT: The type of the numerical value (e.g., Float64, ComplexF64).\n\nReturns\n\nAbstractTolerance: A default tolerance object.\n\nExample\n\nusing RootSolvers\n\n# Find the default tolerance for Float64\ntol = default_tol(Float64)\nprintln(\"Default tolerance for Float64: \", tol)\n# Default tolerance for Float64: SolutionTolerance{Float64}(1e-4)\n\n\n\n\n\n","category":"function"},{"location":"DeveloperDocs/#Core-Types","page":"Developer Documentation","title":"Core Types","text":"","category":"section"},{"location":"DeveloperDocs/#RootSolvingMethod","page":"Developer Documentation","title":"RootSolvingMethod","text":"","category":"section"},{"location":"DeveloperDocs/#RootSolvers.RootSolvingMethod","page":"Developer Documentation","title":"RootSolvers.RootSolvingMethod","text":"RootSolvingMethod{FT} <: AbstractType\n\nAbstract type for root-finding methods in RootSolvers.jl.\n\nThis is the base type for all numerical methods used to find roots of scalar functions. Each concrete method type should implement the method_args function to extract initial guesses and parameters for the solver.\n\nType Parameters\n\nFT: The floating-point type for computations (e.g., Float64, Float32)\n\nConcrete Implementations\n\nSecantMethod{FT}: Linear interpolation between two points\nRegulaFalsiMethod{FT}: Bracketing method with linear interpolation\nBisectionMethod{FT}: Simple bracketing method with guaranteed convergence\nBrentsMethod{FT}: Robust bracketing method combining multiple techniques\nNewtonsMethodAD{FT}: Newton's method with automatic differentiation\nNewtonsMethod{FT}: Newton's method with user-provided derivatives\n\nInterface Requirements\n\nAll concrete subtypes must implement:\n\nmethod_args(method): Return initial guesses as a tuple\nfind_zero(f, method, args..., soltype, tol, maxiters): Main solver implementation\n\nExample\n\n# Define a custom method\nstruct MyCustomMethod{FT} <: RootSolvingMethod{FT}\n    x0::FT\nend\n\n# Implement required interface\nmethod_args(method::MyCustomMethod) = (method.x0,)\n\n# Use with find_zero\nsol = find_zero(x -> x^2 - 4, MyCustomMethod{Float64}(1.0))\n\n\n\n\n\n","category":"type"},{"location":"DeveloperDocs/#SolutionType","page":"Developer Documentation","title":"SolutionType","text":"","category":"section"},{"location":"DeveloperDocs/#RootSolvers.SolutionType","page":"Developer Documentation","title":"RootSolvers.SolutionType","text":"SolutionType <: AbstractType\n\nAbstract type for solution formats in RootSolvers.jl.\n\nThis is the base type for all solution types that control the level of detail returned by find_zero. Each concrete solution type should implement the SolutionResults constructor and history management functions.\n\nConcrete Implementations\n\nCompactSolution: Memory-efficient, GPU-compatible solution with minimal output\nVerboseSolution: CPU-only solution with detailed diagnostics and iteration history\n\nInterface Requirements\n\nAll concrete subtypes must implement:\n\nSolutionResults(soltype, args...): Constructor for the corresponding results type\ninit_history(soltype, x): Initialize history storage for the solution type\npush_history!(history, x, soltype): Add a value to the history\n\nExample\n\n# Define a custom solution type\nstruct MySolution <: SolutionType end\n\n# Implement required interface\nSolutionResults(soltype::MySolution, args...) = MySolutionResults(args...)\ninit_history(::MySolution, x) = [x]\npush_history!(history, x, ::MySolution) = push!(history, x)\n\n# Use with find_zero\nsol = find_zero(x -> x^2 - 4, SecantMethod(1.0, 3.0), MySolution())\n\n\n\n\n\n","category":"type"},{"location":"DeveloperDocs/#Extending-RootSolvers.jl","page":"Developer Documentation","title":"Extending RootSolvers.jl","text":"","category":"section"},{"location":"DeveloperDocs/#Adding-New-Root-Finding-Methods","page":"Developer Documentation","title":"Adding New Root-Finding Methods","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"To add a new root-finding method, you need to:","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Define the method struct:","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"struct MyNewMethod{FT} <: RootSolvingMethod{FT}\n    x0::FT\n    # Add other fields as needed\nend","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Implement method_args:","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"method_args(method::MyNewMethod) = (method.x0,)","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Implement the main find_zero method:","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"function find_zero(\n    f::F,\n    ::MyNewMethod,\n    x0::FT,\n    soltype::SolutionType,\n    tol::AbstractTolerance,\n    maxiters::Int,\n) where {F <: Function, FT}\n    # Your implementation here\n    return _find_zero_my_method(f, x0, soltype, tol, maxiters)\nend","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Implement the core algorithm:","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"function _find_zero_my_method(f, x0, soltype, tol, maxiters)\n    # Your root-finding algorithm implementation\n    # Return a SolutionResults object\nend","category":"page"},{"location":"DeveloperDocs/#Adding-New-Tolerance-Types","page":"Developer Documentation","title":"Adding New Tolerance Types","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"To add a new tolerance type:","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Define the tolerance struct:","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"struct MyTolerance{FT} <: AbstractTolerance{FT}\n    tol::FT\nend","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Implement the callable interface:","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"(tol::MyTolerance)(x1, x2, y) = # your convergence criterion","category":"page"},{"location":"DeveloperDocs/#Adding-New-Solution-Types","page":"Developer Documentation","title":"Adding New Solution Types","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"To add a new solution type:","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Define the solution type:","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"struct MySolution <: SolutionType end","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Define the results struct:","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"struct MySolutionResults{FT} <: AbstractSolutionResults{FT}\n    root::FT\n    converged::Bool\n    # Add other fields as needed\nend","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Implement the constructor:","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"SolutionResults(soltype::MySolution, args...) = MySolutionResults(args...)","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Implement history functions:","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"init_history(::MySolution, x::FT) where {FT <: Real} = # your initialization\npush_history!(history, x, ::MySolution) = # your push logic","category":"page"},{"location":"DeveloperDocs/#Performance-Considerations","page":"Developer Documentation","title":"Performance Considerations","text":"","category":"section"},{"location":"DeveloperDocs/#GPU-Compatibility","page":"Developer Documentation","title":"GPU Compatibility","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"When extending RootSolvers.jl for GPU compatibility:","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Use ifelse instead of if-else blocks where possible\nAvoid dynamic dispatch in hot loops\nEnsure all functions are type-stable\nUse CompactSolution for GPU operations (avoid VerboseSolution)","category":"page"},{"location":"DeveloperDocs/#Memory-Management","page":"Developer Documentation","title":"Memory Management","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"CompactSolution is memory-efficient and GPU-compatible\nVerboseSolution stores iteration history and is CPU-only\nConsider memory usage when implementing new solution types","category":"page"},{"location":"DeveloperDocs/#Type-Stability","page":"Developer Documentation","title":"Type Stability","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Ensure all functions return consistent types\nUse Base.Fix1 for function composition instead of anonymous functions\nAvoid type instability in hot loops","category":"page"},{"location":"DeveloperDocs/#Testing-Guidelines","page":"Developer Documentation","title":"Testing Guidelines","text":"","category":"section"},{"location":"DeveloperDocs/#Test-Structure","page":"Developer Documentation","title":"Test Structure","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"The tests are located in the test/ directory:","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"test/runtests.jl: Main test suite with comprehensive tests for all methods\ntest/runtests_kernel.jl: GPU kernel tests for CUDA compatibility\ntest/test_helper.jl: Helper functions and test utilities\ntest/test_printing.jl: Tests for solution printing and formatting","category":"page"},{"location":"DeveloperDocs/#What-Tests-Cover","page":"Developer Documentation","title":"What Tests Cover","text":"","category":"section"},{"location":"DeveloperDocs/#test/runtests.jl","page":"Developer Documentation","title":"test/runtests.jl","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"All root-finding methods: Secant, Regula Falsi, Brent's, Newton's (AD and manual)\nAll tolerance types: Solution, Residual, Relative, and combined tolerances\nAll solution types: Compact and Verbose solutions\nEdge cases: Non-finite inputs, convergence failures, high-multiplicity roots\nBroadcasting: Array and GPU compatibility\nType stability: Different floating-point types (Float32, Float64)","category":"page"},{"location":"DeveloperDocs/#test/runtests_kernel.jl","page":"Developer Documentation","title":"test/runtests_kernel.jl","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"GPU kernel tests: CUDA array compatibility\nBroadcasting on GPU: Parallel root-finding on GPU arrays\nMemory efficiency: GPU memory usage and allocation","category":"page"},{"location":"DeveloperDocs/#test/test_helper.jl","page":"Developer Documentation","title":"test/test_helper.jl","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Test utilities: Helper functions for generating test problems\nMethod type definitions: Test-specific method types\nProblem generators: Functions to create test cases","category":"page"},{"location":"DeveloperDocs/#test/test_printing.jl","page":"Developer Documentation","title":"test/test_printing.jl","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Solution formatting: Compact and verbose solution display\nColor output: Terminal color coding for convergence status\nHistory display: Iteration history formatting","category":"page"},{"location":"DeveloperDocs/#Running-Tests","page":"Developer Documentation","title":"Running Tests","text":"","category":"section"},{"location":"DeveloperDocs/#Basic-Test-Suite","page":"Developer Documentation","title":"Basic Test Suite","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"# From the project root\njulia --project=. -e \"using Pkg; Pkg.test()\"\n\n# Or using the test script directly\njulia --project=. test/runtests.jl","category":"page"},{"location":"DeveloperDocs/#Specific-Test-Files","page":"Developer Documentation","title":"Specific Test Files","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"# Run the main test suite\njulia --project=. test/runtests.jl\n\n# Run GPU kernel tests alone (requires CUDA.jl)\njulia --project=. test/runtests_kernel.jl\n\n# Run printing tests\njulia --project=. test/test_printing.jl","category":"page"},{"location":"DeveloperDocs/#GPU-Tests","page":"Developer Documentation","title":"GPU Tests","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"# Run GPU tests (requires CUDA.jl and compatible GPU)\njulia --project=. test/runtests_kernel.jl","category":"page"},{"location":"DeveloperDocs/#Test-Coverage","page":"Developer Documentation","title":"Test Coverage","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"The test suite aims for comprehensive coverage:","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Unit tests: Test individual functions and methods\nGPU tests: Test CUDA compatibility and performance\nEdge case tests: Handle difficult convergence scenarios\nType stability tests: Ensure GPU compatibility\nBroadcasting tests: Test array and GPU operations","category":"page"},{"location":"DeveloperDocs/#Continuous-Integration","page":"Developer Documentation","title":"Continuous Integration","text":"","category":"section"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"Tests are automatically run on:","category":"page"},{"location":"DeveloperDocs/","page":"Developer Documentation","title":"Developer Documentation","text":"GitHub Actions: Multiple Julia versions and operating systems\nCode coverage: Tracked via CodeCov\nGPU tests: Run on CUDA-compatible runners","category":"page"},{"location":"#RootSolvers.jl","page":"Home","title":"RootSolvers.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RootSolvers.jl is a Julia package for finding roots of nonlinear equations using robust, efficient, and GPU-capable numerical methods. It provides a simple, unified interface for a variety of classic root-finding algorithms, with flexible convergence criteria and solution reporting. The package supports dual numbers for automatic differentiation, making it suitable for integration into differentiable models and optimization problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Getting Started: Installation, quick start, and how-to guide\nAPI Reference: Full documentation of all methods and types","category":"page"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Getting Started page for more details and examples.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Install stable release:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"RootSolvers\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Find a root of a quadratic equation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using RootSolvers\n\n# Find the root of x^2 - 100^2 using the secant method\nsol = find_zero(x -> x^2 - 100^2, SecantMethod(0.0, 1000.0))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or use Brent's method for robust bracketing","category":"page"},{"location":"","page":"Home","title":"Home","text":"sol = find_zero(x -> x^2 - 100^2, BrentsMethod(-200.0, 0.0))","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Getting Started\nAPI Reference\nDeveloper Documentation","category":"page"},{"location":"API/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"This page provides the complete API reference for RootSolvers.jl. For a more narrative introduction, see the Getting Started guide.","category":"page"},{"location":"API/#Module-Overview","page":"API","title":"Module Overview","text":"","category":"section"},{"location":"API/#RootSolvers.RootSolvers","page":"API","title":"RootSolvers.RootSolvers","text":"RootSolvers.jl\n\nA Julia package for solving roots of non-linear equations using various numerical methods. Contains functions for finding zeros of scalar functions using robust iterative algorithms.\n\nThe main entry point is find_zero, which supports multiple root-finding methods and tolerance criteria.\n\nSupported Methods\n\nSecant Method: Requires two initial guesses, uses linear interpolation\nBisection Method: Requires bracketing interval with sign change, converges linearly\nRegula Falsi Method: Requires bracketing interval with sign change\nBrent's Method: Requires bracketing interval, combines bisection, secant, and inverse quadratic interpolation\nNewton's Method with AD: Requires one initial guess, uses automatic differentiation\nNewton's Method: Requires one initial guess and user-provided derivative\n\nMethod Selection Guide\n\nBracketing methods (Bisection, Regula Falsi, Brent's): Use when you know an interval containing the root\nBrent's method: Recommended for robust, guaranteed convergence with superlinear rate\nSecant method: Good when you have two guesses but no bracketing interval\nNewton's methods: Fastest convergence when you have a good initial guess\n\nExample\n\nusing RootSolvers\n\n# Find the square root of a quadratic equation using the secant method\nsol = find_zero(x -> x^2 - 100^2,\n               SecantMethod{Float64}(0.0, 1000.0),\n               CompactSolution());\n\nprintln(sol)\n# CompactSolutionResults{Float64}:\n# ├── Status: converged\n# └── Root: 99.99999999994358\n\n# Access the root value\nroot_value = sol.root  # 99.99999999994358\n\n# Use Brent's method for robust convergence with bracketing interval\nsol_brent = find_zero(x -> x^3 - 8,\n                     BrentsMethod{Float64}(-1.0, 3.0),\n                     CompactSolution());\n\n# Use Newton's method with automatic differentiation for faster convergence\nsol_newton = find_zero(x -> x^3 - 27,\n                      NewtonsMethodAD{Float64}(2.0),\n                      VerboseSolution());\n\n\n\n\n\n","category":"module"},{"location":"API/#Main-Function","page":"API","title":"Main Function","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"The primary entry point for the package is the find_zero function.","category":"page"},{"location":"API/#RootSolvers.find_zero","page":"API","title":"RootSolvers.find_zero","text":"find_zero(f, method, soltype=CompactSolution(), tol=nothing, maxiters=1_000)\n\nFind a root of the scalar function f using the specified numerical method.\n\nThis is the main entry point for root finding in RootSolvers.jl. Given a function f, it finds a value x such that f(x) ≈ 0 using iterative numerical methods. The function supports various root-finding algorithms, tolerance criteria, and solution formats.\n\nArguments\n\nf::Function: The function for which to find a root. Should take a scalar input and return a scalar output.\nmethod::RootSolvingMethod: The numerical method to use. Available methods:\nBisectionMethod: Bracketing method maintaining sign change (linear convergence, guaranteed)\nSecantMethod: Uses linear interpolation between two points (superlinear convergence)\nRegulaFalsiMethod: Bracketing method maintaining sign change (linear convergence, guaranteed)\nNewtonsMethodAD: Newton's method with automatic differentiation (quadratic convergence)\nNewtonsMethod: Newton's method with user-provided derivative (quadratic convergence)\nsoltype::SolutionType: Format of the returned solution (default: CompactSolution()):\nCompactSolution: Returns only root and convergence status (GPU-compatible)\nVerboseSolution: Returns detailed diagnostics and iteration history (CPU-only)\ntol::Union{Nothing, AbstractTolerance}: Convergence criterion (default: SolutionTolerance(1e-3)):\nResidualTolerance: Based on |f(x)|\nSolutionTolerance: Based on |x_{n+1} - x_n|\nRelativeSolutionTolerance: Based on |(x_{n+1} - x_n)/x_n|\nRelativeOrAbsoluteSolutionTolerance: Combined relative and absolute tolerance\nmaxiters::Int: Maximum number of iterations allowed (default: 10,000)\n\nReturns\n\nAbstractSolutionResults: Solution object containing the root and convergence information. The exact type depends on the soltype parameter:\nCompactSolutionResults: Contains root and converged fields\nVerboseSolutionResults: Additionally contains err, iter_performed, and iteration history\n\nExamples\n\nusing RootSolvers\n\n# Find square root of 2 using secant method\nsol = find_zero(x -> x^2 - 2, SecantMethod{Float64}(1.0, 2.0))\nprintln(\"√2 ≈ $(sol.root)\")  # √2 ≈ 1.4142135623730951\n\n# Use Newton's method with automatic differentiation for faster convergence\nsol = find_zero(x -> x^3 - 27, NewtonsMethodAD{Float64}(2.0))\nprintln(\"∛27 = $(sol.root)\")  # ∛27 = 3.0\n\n# Get detailed iteration history\nsol = find_zero(x -> exp(x) - 2, \n               NewtonsMethodAD{Float64}(0.5), \n               VerboseSolution())\nprintln(\"ln(2) ≈ $(sol.root) found in $(sol.iter_performed) iterations\")\n\n# Use custom tolerance\ntol = RelativeOrAbsoluteSolutionTolerance(1e-12, 1e-15)\nsol = find_zero(x -> cos(x), \n               NewtonsMethodAD{Float64}(1.0), \n               CompactSolution(), \n               tol)\nprintln(\"π/2 ≈ $(sol.root)\")\n\n# Robust bracketing method for difficult functions\nsol = find_zero(x -> x^3 - 2x - 5, RegulaFalsiMethod{Float64}(2.0, 3.0))\n\nBatch and GPU Root-Finding (Broadcasting)\n\nYou can broadcast find_zero over arrays of methods or initial guesses to solve many root-finding problems in parallel, including on the GPU:\n\nusing CUDA, RootSolvers\nx0 = CUDA.fill(1.0, 1000)  # 1000 initial guesses on the GPU\nmethod = SecantMethod.(x0, x0 .+ 1)\n# f should be broadcastable over arrays\nsol = find_zero.(x -> x.^2 .- 2, method, CompactSolution())\n\nThis is especially useful for large-scale or batched root-finding on GPUs. Only CompactSolution is GPU-compatible.\n\nMethod Selection Guide\n\nBisectionMethod: Simple general-purpose bracketing method, slow but guaranteed convergence\nSecantMethod: Good general-purpose method, no derivatives needed\nRegulaFalsiMethod: Use when you need guaranteed convergence with a bracketing interval\nNewtonsMethodAD: Fastest convergence when derivatives are available via autodiff\nNewtonsMethod: Use when you can provide analytical derivatives efficiently\n\nSee Also\n\nBisectionMethod, SecantMethod, RegulaFalsiMethod, NewtonsMethodAD, NewtonsMethod\nCompactSolution, VerboseSolution\nResidualTolerance, SolutionTolerance\n\n\n\n\n\n","category":"function"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/#Numerical-Methods","page":"API","title":"Numerical Methods","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"The following structs are used to select the root-finding algorithm.","category":"page"},{"location":"API/","page":"API","title":"API","text":"Method Requirements Best For\nSecantMethod 2 initial guesses No derivatives, fast convergence\nRegulaFalsiMethod Bracketing interval (sign change) Guaranteed convergence\nBisectionMethod Bracketing interval (sign change) Guaranteed convergence, simple\nBrentsMethod Bracketing interval (sign change) Superlinear convergence, robust\nNewtonsMethodAD 1 initial guess, differentiable f Fastest, uses autodiff, robust step control\nNewtonsMethod 1 initial guess, f and f' provided Analytical derivatives, robust step control","category":"page"},{"location":"API/#RootSolvers.SecantMethod","page":"API","title":"RootSolvers.SecantMethod","text":"SecantMethod{FT} <: RootSolvingMethod{FT}\n\nThe secant method for root finding, which uses linear interpolation between two points to approximate the derivative. This method requires two initial guesses but does not require the function to be differentiable or the guesses to bracket a root.\n\nThe method uses the recurrence relation:\n\nx_n+1 = x_n - f(x_n) fracx_n - x_n-1f(x_n) - f(x_n-1)\n\nConvergence\n\nOrder: Approximately 1.618 (superlinear)\nRequirements: Two initial guesses, continuous function\nAdvantages: No derivative required, fast convergence\nDisadvantages: May not converge if initial guesses are poor\n\nFields\n\nx0::FT: First initial guess\nx1::FT: Second initial guess\n\nExample\n\nmethod = SecantMethod{Float64}(0.0, 2.0)\nsol = find_zero(x -> x^3 - 8, method)\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.RegulaFalsiMethod","page":"API","title":"RootSolvers.RegulaFalsiMethod","text":"RegulaFalsiMethod{FT} <: RootSolvingMethod{FT}\n\nThe Regula Falsi (false position) method for root finding. This is a bracketing method that maintains the sign change property and uses linear interpolation to find the root.\n\nThe method requires that f(x0) and f(x1) have opposite signs, ensuring that a root exists in the interval [x0, x1].\n\nConvergence\n\nOrder: Linear (slower than Newton's method)\nRequirements: Bracketing interval with f(x0) * f(x1) < 0\nAdvantages: Guaranteed convergence, robust\nDisadvantages: Slower convergence than other methods\n\nFields\n\nx0::FT: Lower bound of bracketing interval\nx1::FT: Upper bound of bracketing interval\n\nExample\n\n# Find root of x^3 - 2 in interval [-1, 2]\nmethod = RegulaFalsiMethod{Float64}(-1.0, 2.0)\nsol = find_zero(x -> x^3 - 2, method)\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.BisectionMethod","page":"API","title":"RootSolvers.BisectionMethod","text":"BisectionMethod{FT} <: RootSolvingMethod{FT}\n\nThe bisection method for root finding. This is a simple bracketing method that divides the interval in half at each iteration. The method requires that f(x0) and f(x1) have opposite signs, ensuring that a root exists in the interval [x0, x1].\n\nThe method uses the recurrence relation:\n\nx_n+1 = fracx_0 + x_12\n\nwhere the interval [x0, x1] is updated based on the sign of f(x_{n+1}).\n\nConvergence\n\nOrder: Linear (slower than Newton's method)\nRequirements: Bracketing interval with f(x0) * f(x1) < 0\nAdvantages: Guaranteed convergence, simple implementation\nDisadvantages: Slower convergence than other methods\n\nFields\n\nx0::FT: Lower bound of bracketing interval\nx1::FT: Upper bound of bracketing interval\n\nExample\n\n# Find root of x^3 - 2 in interval [-1, 2]\nmethod = BisectionMethod{Float64}(-1.0, 2.0)\nsol = find_zero(x -> x^3 - 2, method)\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.BrentsMethod","page":"API","title":"RootSolvers.BrentsMethod","text":"BrentsMethod{FT} <: RootSolvingMethod{FT}\n\nBrent's method for root finding, which combines the bisection method, secant method, and inverse quadratic interpolation. This is a bracketing method that maintains the sign change property and provides superlinear convergence.\n\nThe method requires that f(x0) and f(x1) have opposite signs, ensuring that a root exists in the interval [x0, x1].\n\nConvergence\n\nOrder: Superlinear (faster than Regula Falsi)\nRequirements: Bracketing interval with f(x0) * f(x1) < 0\nAdvantages: Guaranteed convergence, fast convergence, robust\nDisadvantages: More complex than simpler bracketing methods\n\nFields\n\nx0::FT: Lower bound of bracketing interval\nx1::FT: Upper bound of bracketing interval\n\nExample\n\n# Find root of x^3 - 2 in interval [-1, 2]\nmethod = BrentsMethod{Float64}(-1.0, 2.0)\nsol = find_zero(x -> x^3 - 2, method)\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.NewtonsMethodAD","page":"API","title":"RootSolvers.NewtonsMethodAD","text":"NewtonsMethodAD{FT} <: RootSolvingMethod{FT}\n\nNewton's method for root finding using automatic differentiation to compute derivatives. This method provides quadratic convergence when close to the root and the derivative is non-zero. The implementation includes step size limiting and backtracking line search for robustness.\n\nThe method uses the iteration\n\nx_n+1 = x_n - fracf(x_n)f(x_n)\n\nwhere the derivative f'(x_n) is computed using ForwardDiff.jl.\n\nConvergence\n\nOrder: Quadratic (very fast near the root)\nRequirements: Differentiable function, good initial guess\nAdvantages: Fast convergence, automatic derivative computation, robust step size control\nDisadvantages: May not converge if initial guess is poor or derivative is zero\n\nFields\n\nx0::FT: Initial guess for the root\n\nExample\n\n# Find cube root of 27\nmethod = NewtonsMethodAD{Float64}(2.0)\nsol = find_zero(x -> x^3 - 27, method)\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.NewtonsMethod","page":"API","title":"RootSolvers.NewtonsMethod","text":"NewtonsMethod{FT} <: RootSolvingMethod{FT}\n\nNewton's method for root finding where the user provides both the function and its derivative. This method provides quadratic convergence when close to the root. The implementation includes step size limiting and backtracking line search for robustness.\n\nThe method uses the iteration\n\nx_n+1 = x_n - fracf(x_n)f(x_n)\n\nConvergence\n\nOrder: Quadratic (very fast near the root)\nRequirements: Function and derivative, good initial guess\nAdvantages: Fast convergence, no automatic differentiation overhead, robust step size control\nDisadvantages: Requires manual derivative computation\n\nFields\n\nx0::FT: Initial guess for the root\n\nNote\n\nWhen using this method, your function f should return a tuple (f(x), f'(x)) containing both the function value and its derivative at x.\n\nExample\n\n# Find root of x^2 - 4, providing both function and derivative\nf_and_df(x) = (x^2 - 4, 2x)\nmethod = NewtonsMethod{Float64}(1.0)\nsol = find_zero(f_and_df, method)\n\n\n\n\n\n","category":"type"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/#Solution-Types","page":"API","title":"Solution Types","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"These types control the level of detail in the output returned by find_zero.","category":"page"},{"location":"API/","page":"API","title":"API","text":"Solution Type Features Best For\nCompactSolution Minimal output, GPU-friendly High-performance, GPU, memory efficiency\nVerboseSolution Full diagnostics, iteration history Debugging, analysis, CPU","category":"page"},{"location":"API/#RootSolvers.CompactSolution","page":"API","title":"RootSolvers.CompactSolution","text":"CompactSolution <: SolutionType\n\nA memory-efficient solution type that returns only essential information about the root.\n\nWhen used with find_zero, returns a CompactSolutionResults object containing only the root value and convergence status. This solution type is GPU-compatible and suitable for high-performance applications where memory usage is critical.\n\nAccessing Results\n\nThe returned CompactSolutionResults object contains the following fields:\n\nsol.root: The found root value\nsol.converged: Boolean indicating if the method converged\n\nExample\n\nsol = find_zero(x -> x^2 - 4, \n               SecantMethod{Float64}(0.0, 3.0), \n               CompactSolution())\n\n# Access the root\nprintln(\"Root: $(sol.root)\")\n\n# Check convergence\nif sol.converged\n    println(\"Root found successfully!\")\nelse\n    println(\"Method failed to converge\")\nend\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.VerboseSolution","page":"API","title":"RootSolvers.VerboseSolution","text":"VerboseSolution <: SolutionType\n\nA solution type that returns detailed information about the root-finding process, including iteration history and convergence diagnostics.\n\nWhen used with find_zero, returns a VerboseSolutionResults object containing the root, convergence status, error information, and complete iteration history.\n\nAccessing Results\n\nThe returned VerboseSolutionResults object contains the following fields:\n\nsol.root: The found root value\nsol.converged: Boolean indicating if the method converged\nsol.err: Final error value (function value at the root)\nsol.iter_performed: Number of iterations performed\nsol.root_history: Vector of all root values during iteration\nsol.err_history: Vector of all error values during iteration\n\nNote\n\nThis solution type stores iteration history and is primarily intended for CPU computations. For GPU computations or when memory usage is a concern, use CompactSolution instead.\n\nExample\n\nsol = find_zero(x -> x^2 - 4, SecantMethod(1.0, 3.0), VerboseSolution())\n\n# Access the root\nroot_value = sol.root\n\n# Check convergence and diagnostics\nif sol.converged\n    println(\"Root found: \", root_value)\n    println(\"Converged in \", sol.iter_performed, \" iterations\")\n    println(\"Final error: \", sol.err)\nelse\n    println(\"Method failed to converge\")\nend\n\n# Access iteration history\nprintln(\"First iteration root: \", sol.root_history[1])\nprintln(\"Last iteration root: \", sol.root_history[end])\n\n\n\n\n\n","category":"type"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/#Tolerance-Types","page":"API","title":"Tolerance Types","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Tolerance types define the convergence criteria for the solver.","category":"page"},{"location":"API/","page":"API","title":"API","text":"Tolerance Type Criterion Best For\nSolutionTolerance           ) abs(x₂ - x₁) When you want iterates to stabilize\nResidualTolerance abs(f(x)) When you want the function value near zero\nRelativeSolutionTolerance abs((x₂ - x₁)/x₁) When root magnitude varies widely\nRelativeOrAbsoluteSolutionTolerance Relative or Absolute Robust for both small and large roots","category":"page"},{"location":"API/#RootSolvers.AbstractTolerance","page":"API","title":"RootSolvers.AbstractTolerance","text":"AbstractTolerance{FT} <: AbstractType\n\nAbstract type for tolerance criteria in RootSolvers.jl.\n\nThis is the base type for all tolerance types that define convergence criteria for root-finding algorithms. Each concrete tolerance type should implement the callable interface (tol)(x1, x2, y) for convergence checking.\n\nType Parameters\n\nFT: The floating-point type for tolerance values (e.g., Float64, Float32)\n\nConcrete Implementations\n\nResidualTolerance{FT}: Based on |f(x)|\nSolutionTolerance{FT}: Based on |x_{n+1} - x_n|\nRelativeSolutionTolerance{FT}: Based on |(x_{n+1} - x_n)/x_n|\nRelativeOrAbsoluteSolutionTolerance{FT}: Combined relative and absolute tolerance\n\nInterface Requirements\n\nAll concrete subtypes must implement:\n\n(tol)(x1, x2, y): Check convergence using three arguments (previous iterate, current iterate, function value)\n\nExample\n\n# Define a custom tolerance type\nstruct MyTolerance{FT} <: AbstractTolerance{FT}\n    threshold::FT\nend\n\n# Implement the required interface\n(tol::MyTolerance)(x1, x2, y) = abs(x2 - x1) < tol.threshold || abs(y) < eps(typeof(y))\n\n# Use with find_zero\nsol = find_zero(x -> x^2 - 4, SecantMethod(1.0, 3.0), CompactSolution(), MyTolerance(1e-6))\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.SolutionTolerance","page":"API","title":"RootSolvers.SolutionTolerance","text":"SolutionTolerance{FT}\n\nA convergence criterion based on the absolute difference between consecutive iterates. The iteration stops when |x_{n+1} - x_n| < tol, where tol is the specified tolerance. Convergence is also triggered if |f(x)| is smaller than the machine epsilon for the value type.\n\nThis tolerance is appropriate when you want to ensure that consecutive iterates are sufficiently close, indicating that the solution has stabilized.\n\nFields\n\ntol::FT: Tolerance threshold for |x_{n+1} - x_n|\n\nExample\n\ntol = SolutionTolerance(1e-8)\nsol = find_zero(x -> x^3 - 8, \n               SecantMethod{Float64}(1.0, 3.0),\n               CompactSolution(),\n               tol)\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.ResidualTolerance","page":"API","title":"RootSolvers.ResidualTolerance","text":"ResidualTolerance{FT}\n\nA convergence criterion based on the absolute value of the residual (function value). The iteration stops when |f(x)| < tol, where tol is the specified tolerance (limited to  the machine epsilon of the function value type).\n\nThis tolerance is appropriate when you want to ensure that the function value is sufficiently close to zero, regardless of how close consecutive iterates are.\n\nFields\n\ntol::FT: Tolerance threshold for |f(x)|\n\nExample\n\ntol = ResidualTolerance(1e-10)\nsol = find_zero(x -> x^2 - 4, \n               NewtonsMethodAD{Float64}(1.0),\n               CompactSolution(),\n               tol)\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.RelativeSolutionTolerance","page":"API","title":"RootSolvers.RelativeSolutionTolerance","text":"RelativeSolutionTolerance{FT}\n\nA convergence criterion based on the relative difference between consecutive iterates. The iteration stops when |(x_{n+1} - x_n)/x_n| < tol, where tol is the specified tolerance.  Convergence is also triggered if |f(x)| is smaller than the machine epsilon for the value type.\n\nThis tolerance is appropriate when you want to convergence relative to the magnitude of the solution, which is useful when the root value might be very large or very small.\n\nFields\n\ntol::FT: Relative tolerance threshold\n\nWarning\n\nThis tolerance criterion can fail if x_n ≈ 0 during iteration, as it involves division by x_n. Consider using RelativeOrAbsoluteSolutionTolerance for more robust behavior.\n\nExample\n\ntol = RelativeSolutionTolerance(1e-6)\nsol = find_zero(x -> x^2 - 1e6, \n               NewtonsMethodAD{Float64}(500.0),\n               CompactSolution(),\n               tol)\n\n\n\n\n\n","category":"type"},{"location":"API/#RootSolvers.RelativeOrAbsoluteSolutionTolerance","page":"API","title":"RootSolvers.RelativeOrAbsoluteSolutionTolerance","text":"RelativeOrAbsoluteSolutionTolerance{FT}\n\nA robust convergence criterion combining both relative and absolute tolerances. The iteration stops when either |(x_{n+1} - x_n)/x_n| < rtol OR |x_{n+1} - x_n| < atol.\n\nThis tolerance provides robust behavior across different scales of root values:\n\nThe relative tolerance rtol ensures accuracy for large roots\nThe absolute tolerance atol ensures convergence when the root is near zero\n\nFields\n\nrtol::FT: Relative tolerance threshold\natol::FT: Absolute tolerance threshold\n\nExample\n\n# Use relative tolerance of 1e-6 and absolute tolerance of 1e-10\ntol = RelativeOrAbsoluteSolutionTolerance(1e-6, 1e-10)\nsol = find_zero(x -> x^2 - 1e-8, \n               NewtonsMethodAD{Float64}(1e-3),\n               CompactSolution(),\n               tol)\n\n\n\n\n\n","category":"type"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/#Broadcasting-and-High-Performance-Computing","page":"API","title":"Broadcasting and High-Performance Computing","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"RootSolvers.jl is designed for high-performance computing applications and supports broadcasting to solve many problems in parallel. This is especially useful for GPU arrays or custom field types used in scientific modeling.","category":"page"},{"location":"API/","page":"API","title":"API","text":"The custom broadcasting rule unpacks initial guesses from the method struct while treating all other arguments as scalars. This enables a clean API for batch-solving.","category":"page"},{"location":"API/","page":"API","title":"API","text":"For more information about broadcasting, see the examples in the find_zero documentation.","category":"page"},{"location":"API/","page":"API","title":"API","text":"","category":"page"},{"location":"API/#Developer-Documentation","page":"API","title":"Developer Documentation","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"For information about internal methods, extending RootSolvers.jl, and developer-focused functionality, see the Developer Documentation.","category":"page"}]
}
