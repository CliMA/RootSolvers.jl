<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · RootSolvers.jl</title><meta name="title" content="API · RootSolvers.jl"/><meta property="og:title" content="API · RootSolvers.jl"/><meta property="twitter:title" content="API · RootSolvers.jl"/><meta name="description" content="Documentation for RootSolvers.jl."/><meta property="og:description" content="Documentation for RootSolvers.jl."/><meta property="twitter:description" content="Documentation for RootSolvers.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="RootSolvers.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">RootSolvers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../GettingStarted/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Module-Overview"><span>Module Overview</span></a></li><li><a class="tocitem" href="#Main-Function"><span>Main Function</span></a></li><li><a class="tocitem" href="#Numerical-Methods"><span>Numerical Methods</span></a></li><li><a class="tocitem" href="#Solution-Types"><span>Solution Types</span></a></li><li><a class="tocitem" href="#Tolerance-Types"><span>Tolerance Types</span></a></li><li><a class="tocitem" href="#Broadcasting-and-High-Performance-Computing"><span>Broadcasting and High-Performance Computing</span></a></li><li><a class="tocitem" href="#Developer-Documentation"><span>Developer Documentation</span></a></li></ul></li><li><a class="tocitem" href="../DeveloperDocs/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/RootSolvers.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/RootSolvers.jl/blob/main/docs/src/API.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>This page provides the complete API reference for RootSolvers.jl. For a more narrative introduction, see the Getting Started guide.</p><h2 id="Module-Overview"><a class="docs-heading-anchor" href="#Module-Overview">Module Overview</a><a id="Module-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Overview" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RootSolvers.RootSolvers" href="#RootSolvers.RootSolvers"><code>RootSolvers.RootSolvers</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>RootSolvers.jl</p><p>A Julia package for solving roots of non-linear equations using various numerical methods. Contains functions for finding zeros of scalar functions using robust iterative algorithms.</p><p>The main entry point is <a href="#RootSolvers.find_zero"><code>find_zero</code></a>, which supports multiple root-finding methods and tolerance criteria.</p><p><strong>Supported Methods</strong></p><ul><li><strong>Secant Method</strong>: Requires two initial guesses, uses linear interpolation</li><li><strong>Bisection Method</strong>: Requires bracketing interval with sign change, converges linearly</li><li><strong>Regula Falsi Method</strong>: Requires bracketing interval with sign change</li><li><strong>Brent&#39;s Method</strong>: Requires bracketing interval, combines bisection, secant, and inverse quadratic interpolation</li><li><strong>Newton&#39;s Method with AD</strong>: Requires one initial guess, uses automatic differentiation</li><li><strong>Newton&#39;s Method</strong>: Requires one initial guess and user-provided derivative</li></ul><p><strong>Method Selection Guide</strong></p><ul><li><strong>Bracketing methods</strong> (Bisection, Regula Falsi, Brent&#39;s): Use when you know an interval containing the root</li><li><strong>Brent&#39;s method</strong>: Recommended for robust, guaranteed convergence with superlinear rate</li><li><strong>Secant method</strong>: Good when you have two guesses but no bracketing interval</li><li><strong>Newton&#39;s methods</strong>: Fastest convergence when you have a good initial guess</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using RootSolvers

# Find the square root of a quadratic equation using the secant method
sol = find_zero(x -&gt; x^2 - 100^2,
               SecantMethod{Float64}(0.0, 1000.0),
               CompactSolution());

println(sol)
# CompactSolutionResults{Float64}:
# ├── Status: converged
# └── Root: 99.99999999994358

# Access the root value
root_value = sol.root  # 99.99999999994358

# Use Brent&#39;s method for robust convergence with bracketing interval
sol_brent = find_zero(x -&gt; x^3 - 8,
                     BrentsMethod{Float64}(-1.0, 3.0),
                     CompactSolution());

# Use Newton&#39;s method with automatic differentiation for faster convergence
sol_newton = find_zero(x -&gt; x^3 - 27,
                      NewtonsMethodAD{Float64}(2.0),
                      VerboseSolution());</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/RootSolvers.jl/blob/5cb11b0636424fb61d86fa5507eef2a46a6c0b33/src/RootSolvers.jl#L1-L53">source</a></section></article><h2 id="Main-Function"><a class="docs-heading-anchor" href="#Main-Function">Main Function</a><a id="Main-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Function" title="Permalink"></a></h2><p>The primary entry point for the package is the <code>find_zero</code> function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RootSolvers.find_zero" href="#RootSolvers.find_zero"><code>RootSolvers.find_zero</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_zero(f, method, soltype=CompactSolution(), tol=nothing, maxiters=1_000)</code></pre><p>Find a root of the scalar function <code>f</code> using the specified numerical method.</p><p>This is the main entry point for root finding in RootSolvers.jl. Given a function <code>f</code>, it finds a value <code>x</code> such that <code>f(x) ≈ 0</code> using iterative numerical methods. The function supports various root-finding algorithms, tolerance criteria, and solution formats.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: The function for which to find a root. Should take a scalar input and return a scalar output.</li><li><code>method::RootSolvingMethod</code>: The numerical method to use. Available methods:<ul><li><a href="#RootSolvers.BisectionMethod"><code>BisectionMethod</code></a>: Bracketing method maintaining sign change (linear convergence, guaranteed)</li><li><a href="#RootSolvers.SecantMethod"><code>SecantMethod</code></a>: Uses linear interpolation between two points (superlinear convergence)</li><li><a href="#RootSolvers.RegulaFalsiMethod"><code>RegulaFalsiMethod</code></a>: Bracketing method maintaining sign change (linear convergence, guaranteed)</li><li><a href="#RootSolvers.NewtonsMethodAD"><code>NewtonsMethodAD</code></a>: Newton&#39;s method with automatic differentiation (quadratic convergence)</li><li><a href="#RootSolvers.NewtonsMethod"><code>NewtonsMethod</code></a>: Newton&#39;s method with user-provided derivative (quadratic convergence)</li></ul></li><li><code>soltype::</code><a href="../DeveloperDocs/#SolutionType"><code>SolutionType</code></a>: Format of the returned solution (default: <a href="#RootSolvers.CompactSolution"><code>CompactSolution()</code></a>):<ul><li><a href="#RootSolvers.CompactSolution"><code>CompactSolution</code></a>: Returns only root and convergence status (GPU-compatible)</li><li><a href="#RootSolvers.VerboseSolution"><code>VerboseSolution</code></a>: Returns detailed diagnostics and iteration history (CPU-only)</li></ul></li><li><code>tol::Union{Nothing, AbstractTolerance}</code>: Convergence criterion (default: <a href="#RootSolvers.SolutionTolerance"><code>SolutionTolerance(1e-3)</code></a>):<ul><li><a href="#RootSolvers.ResidualTolerance"><code>ResidualTolerance</code></a>: Based on <code>|f(x)|</code></li><li><a href="#RootSolvers.SolutionTolerance"><code>SolutionTolerance</code></a>: Based on <code>|x_{n+1} - x_n|</code></li><li><a href="#RootSolvers.RelativeSolutionTolerance"><code>RelativeSolutionTolerance</code></a>: Based on <code>|(x_{n+1} - x_n)/x_n|</code></li><li><a href="#RootSolvers.RelativeOrAbsoluteSolutionTolerance"><code>RelativeOrAbsoluteSolutionTolerance</code></a>: Combined relative and absolute tolerance</li></ul></li><li><code>maxiters::Int</code>: Maximum number of iterations allowed (default: 10,000)</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractSolutionResults</code>: Solution object containing the root and convergence information. The exact type depends on the <code>soltype</code> parameter:<ul><li><code>CompactSolutionResults</code>: Contains <code>root</code> and <code>converged</code> fields</li><li><code>VerboseSolutionResults</code>: Additionally contains <code>err</code>, <code>iter_performed</code>, and iteration history</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using RootSolvers

# Find square root of 2 using secant method
sol = find_zero(x -&gt; x^2 - 2, SecantMethod{Float64}(1.0, 2.0))
println(&quot;√2 ≈ $(sol.root)&quot;)  # √2 ≈ 1.4142135623730951

# Use Newton&#39;s method with automatic differentiation for faster convergence
sol = find_zero(x -&gt; x^3 - 27, NewtonsMethodAD{Float64}(2.0))
println(&quot;∛27 = $(sol.root)&quot;)  # ∛27 = 3.0

# Get detailed iteration history
sol = find_zero(x -&gt; exp(x) - 2, 
               NewtonsMethodAD{Float64}(0.5), 
               VerboseSolution())
println(&quot;ln(2) ≈ $(sol.root) found in $(sol.iter_performed) iterations&quot;)

# Use custom tolerance
tol = RelativeOrAbsoluteSolutionTolerance(1e-12, 1e-15)
sol = find_zero(x -&gt; cos(x), 
               NewtonsMethodAD{Float64}(1.0), 
               CompactSolution(), 
               tol)
println(&quot;π/2 ≈ $(sol.root)&quot;)

# Robust bracketing method for difficult functions
sol = find_zero(x -&gt; x^3 - 2x - 5, RegulaFalsiMethod{Float64}(2.0, 3.0))</code></pre><p><strong>Batch and GPU Root-Finding (Broadcasting)</strong></p><p>You can broadcast <code>find_zero</code> over arrays of methods or initial guesses to solve many root-finding problems in parallel, including on the GPU:</p><pre><code class="language-julia hljs">using CUDA, RootSolvers
x0 = CUDA.fill(1.0, 1000)  # 1000 initial guesses on the GPU
method = SecantMethod.(x0, x0 .+ 1)
# f should be broadcastable over arrays
sol = find_zero.(x -&gt; x.^2 .- 2, method, CompactSolution())</code></pre><p>This is especially useful for large-scale or batched root-finding on GPUs. Only <a href="#RootSolvers.CompactSolution"><code>CompactSolution</code></a> is GPU-compatible.</p><p><strong>Method Selection Guide</strong></p><ul><li><strong>BisectionMethod</strong>: Simple general-purpose bracketing method, slow but guaranteed convergence</li><li><strong>SecantMethod</strong>: Good general-purpose method, no derivatives needed</li><li><strong>RegulaFalsiMethod</strong>: Use when you need guaranteed convergence with a bracketing interval</li><li><strong>NewtonsMethodAD</strong>: Fastest convergence when derivatives are available via autodiff</li><li><strong>NewtonsMethod</strong>: Use when you can provide analytical derivatives efficiently</li></ul><p><strong>See Also</strong></p><ul><li><a href="#RootSolvers.BisectionMethod"><code>BisectionMethod</code></a>, <a href="#RootSolvers.SecantMethod"><code>SecantMethod</code></a>, <a href="#RootSolvers.RegulaFalsiMethod"><code>RegulaFalsiMethod</code></a>, <a href="#RootSolvers.NewtonsMethodAD"><code>NewtonsMethodAD</code></a>, <a href="#RootSolvers.NewtonsMethod"><code>NewtonsMethod</code></a></li><li><a href="#RootSolvers.CompactSolution"><code>CompactSolution</code></a>, <a href="#RootSolvers.VerboseSolution"><code>VerboseSolution</code></a></li><li><a href="#RootSolvers.ResidualTolerance"><code>ResidualTolerance</code></a>, <a href="#RootSolvers.SolutionTolerance"><code>SolutionTolerance</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/RootSolvers.jl/blob/5cb11b0636424fb61d86fa5507eef2a46a6c0b33/src/RootSolvers.jl#L736-L825">source</a></section></article><hr/><h2 id="Numerical-Methods"><a class="docs-heading-anchor" href="#Numerical-Methods">Numerical Methods</a><a id="Numerical-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Methods" title="Permalink"></a></h2><p>The following structs are used to select the root-finding algorithm.</p><table><tr><th style="text-align: left">Method</th><th style="text-align: left">Requirements</th><th style="text-align: left">Best For</th></tr><tr><td style="text-align: left"><a href="#RootSolvers.SecantMethod"><code>SecantMethod</code></a></td><td style="text-align: left">2 initial guesses</td><td style="text-align: left">No derivatives, <strong>fast</strong> convergence</td></tr><tr><td style="text-align: left"><a href="#RootSolvers.RegulaFalsiMethod"><code>RegulaFalsiMethod</code></a></td><td style="text-align: left">Bracketing interval (sign change)</td><td style="text-align: left"><strong>Guaranteed</strong> convergence</td></tr><tr><td style="text-align: left"><a href="#RootSolvers.BisectionMethod"><code>BisectionMethod</code></a></td><td style="text-align: left">Bracketing interval (sign change)</td><td style="text-align: left"><strong>Guaranteed</strong> convergence, simple</td></tr><tr><td style="text-align: left"><a href="#RootSolvers.BrentsMethod"><code>BrentsMethod</code></a></td><td style="text-align: left">Bracketing interval (sign change)</td><td style="text-align: left"><strong>Superlinear</strong> convergence, robust</td></tr><tr><td style="text-align: left"><a href="#RootSolvers.NewtonsMethodAD"><code>NewtonsMethodAD</code></a></td><td style="text-align: left">1 initial guess, differentiable f</td><td style="text-align: left"><strong>Fastest</strong>, uses autodiff, robust step control</td></tr><tr><td style="text-align: left"><a href="#RootSolvers.NewtonsMethod"><code>NewtonsMethod</code></a></td><td style="text-align: left">1 initial guess, f and f&#39; provided</td><td style="text-align: left"><strong>Analytical</strong> derivatives, robust step control</td></tr></table><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RootSolvers.SecantMethod" href="#RootSolvers.SecantMethod"><code>RootSolvers.SecantMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SecantMethod{FT} &lt;: RootSolvingMethod{FT}</code></pre><p>The secant method for root finding, which uses linear interpolation between two points to approximate the derivative. This method requires two initial guesses but does not require the function to be differentiable or the guesses to bracket a root.</p><p>The method uses the recurrence relation:</p><p class="math-container">\[x_{n+1} = x_n - f(x_n) \frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})}\]</p><p><strong>Convergence</strong></p><ul><li><strong>Order</strong>: Approximately 1.618 (superlinear)</li><li><strong>Requirements</strong>: Two initial guesses, continuous function</li><li><strong>Advantages</strong>: No derivative required, fast convergence</li><li><strong>Disadvantages</strong>: May not converge if initial guesses are poor</li></ul><p><strong>Fields</strong></p><ul><li><code>x0::FT</code>: First initial guess</li><li><code>x1::FT</code>: Second initial guess</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">method = SecantMethod{Float64}(0.0, 2.0)
sol = find_zero(x -&gt; x^3 - 8, method)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/RootSolvers.jl/blob/5cb11b0636424fb61d86fa5507eef2a46a6c0b33/src/RootSolvers.jl#L122-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RootSolvers.RegulaFalsiMethod" href="#RootSolvers.RegulaFalsiMethod"><code>RootSolvers.RegulaFalsiMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RegulaFalsiMethod{FT} &lt;: RootSolvingMethod{FT}</code></pre><p>The Regula Falsi (false position) method for root finding. This is a bracketing method that maintains the sign change property and uses linear interpolation to find the root.</p><p>The method requires that <code>f(x0)</code> and <code>f(x1)</code> have opposite signs, ensuring that a root exists in the interval <code>[x0, x1]</code>.</p><p><strong>Convergence</strong></p><ul><li><strong>Order</strong>: Linear (slower than Newton&#39;s method)</li><li><strong>Requirements</strong>: Bracketing interval with <code>f(x0) * f(x1) &lt; 0</code></li><li><strong>Advantages</strong>: Guaranteed convergence, robust</li><li><strong>Disadvantages</strong>: Slower convergence than other methods</li></ul><p><strong>Fields</strong></p><ul><li><code>x0::FT</code>: Lower bound of bracketing interval</li><li><code>x1::FT</code>: Upper bound of bracketing interval</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Find root of x^3 - 2 in interval [-1, 2]
method = RegulaFalsiMethod{Float64}(-1.0, 2.0)
sol = find_zero(x -&gt; x^3 - 2, method)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/RootSolvers.jl/blob/5cb11b0636424fb61d86fa5507eef2a46a6c0b33/src/RootSolvers.jl#L190-L215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RootSolvers.BisectionMethod" href="#RootSolvers.BisectionMethod"><code>RootSolvers.BisectionMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BisectionMethod{FT} &lt;: RootSolvingMethod{FT}</code></pre><p>The bisection method for root finding. This is a simple bracketing method that divides the interval in half at each iteration. The method requires that <code>f(x0)</code> and <code>f(x1)</code> have opposite signs, ensuring that a root exists in the interval <code>[x0, x1]</code>.</p><p>The method uses the recurrence relation:</p><p class="math-container">\[x_{n+1} = \frac{x_0 + x_1}{2}\]</p><p>where the interval <code>[x0, x1]</code> is updated based on the sign of <code>f(x_{n+1})</code>.</p><p><strong>Convergence</strong></p><ul><li><strong>Order</strong>: Linear (slower than Newton&#39;s method)</li><li><strong>Requirements</strong>: Bracketing interval with <code>f(x0) * f(x1) &lt; 0</code></li><li><strong>Advantages</strong>: Guaranteed convergence, simple implementation</li><li><strong>Disadvantages</strong>: Slower convergence than other methods</li></ul><p><strong>Fields</strong></p><ul><li><code>x0::FT</code>: Lower bound of bracketing interval</li><li><code>x1::FT</code>: Upper bound of bracketing interval</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Find root of x^3 - 2 in interval [-1, 2]
method = BisectionMethod{Float64}(-1.0, 2.0)
sol = find_zero(x -&gt; x^3 - 2, method)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/RootSolvers.jl/blob/5cb11b0636424fb61d86fa5507eef2a46a6c0b33/src/RootSolvers.jl#L155-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RootSolvers.BrentsMethod" href="#RootSolvers.BrentsMethod"><code>RootSolvers.BrentsMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BrentsMethod{FT} &lt;: RootSolvingMethod{FT}</code></pre><p>Brent&#39;s method for root finding, which combines the bisection method, secant method, and inverse quadratic interpolation. This is a bracketing method that maintains the sign change property and provides superlinear convergence.</p><p>The method requires that <code>f(x0)</code> and <code>f(x1)</code> have opposite signs, ensuring that a root exists in the interval <code>[x0, x1]</code>.</p><p><strong>Convergence</strong></p><ul><li><strong>Order</strong>: Superlinear (faster than Regula Falsi)</li><li><strong>Requirements</strong>: Bracketing interval with <code>f(x0) * f(x1) &lt; 0</code></li><li><strong>Advantages</strong>: Guaranteed convergence, fast convergence, robust</li><li><strong>Disadvantages</strong>: More complex than simpler bracketing methods</li></ul><p><strong>Fields</strong></p><ul><li><code>x0::FT</code>: Lower bound of bracketing interval</li><li><code>x1::FT</code>: Upper bound of bracketing interval</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Find root of x^3 - 2 in interval [-1, 2]
method = BrentsMethod{Float64}(-1.0, 2.0)
sol = find_zero(x -&gt; x^3 - 2, method)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/RootSolvers.jl/blob/5cb11b0636424fb61d86fa5507eef2a46a6c0b33/src/RootSolvers.jl#L221-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RootSolvers.NewtonsMethodAD" href="#RootSolvers.NewtonsMethodAD"><code>RootSolvers.NewtonsMethodAD</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NewtonsMethodAD{FT} &lt;: RootSolvingMethod{FT}</code></pre><p>Newton&#39;s method for root finding using automatic differentiation to compute derivatives. This method provides quadratic convergence when close to the root and the derivative is non-zero. The implementation includes step size limiting and backtracking line search for robustness.</p><p>The method uses the iteration</p><p class="math-container">\[x_{n+1} = x_n - \frac{f(x_n)}{f&#39;(x_n)}\]</p><p>where the derivative <code>f&#39;(x_n)</code> is computed using ForwardDiff.jl.</p><p><strong>Convergence</strong></p><ul><li><strong>Order</strong>: Quadratic (very fast near the root)</li><li><strong>Requirements</strong>: Differentiable function, good initial guess</li><li><strong>Advantages</strong>: Fast convergence, automatic derivative computation, robust step size control</li><li><strong>Disadvantages</strong>: May not converge if initial guess is poor or derivative is zero</li></ul><p><strong>Fields</strong></p><ul><li><code>x0::FT</code>: Initial guess for the root</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Find cube root of 27
method = NewtonsMethodAD{Float64}(2.0)
sol = find_zero(x -&gt; x^3 - 27, method)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/RootSolvers.jl/blob/5cb11b0636424fb61d86fa5507eef2a46a6c0b33/src/RootSolvers.jl#L252-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RootSolvers.NewtonsMethod" href="#RootSolvers.NewtonsMethod"><code>RootSolvers.NewtonsMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NewtonsMethod{FT} &lt;: RootSolvingMethod{FT}</code></pre><p>Newton&#39;s method for root finding where the user provides both the function and its derivative. This method provides quadratic convergence when close to the root. The implementation includes step size limiting and backtracking line search for robustness.</p><p>The method uses the iteration</p><p class="math-container">\[x_{n+1} = x_n - \frac{f(x_n)}{f&#39;(x_n)}\]</p><p><strong>Convergence</strong></p><ul><li><strong>Order</strong>: Quadratic (very fast near the root)</li><li><strong>Requirements</strong>: Function and derivative, good initial guess</li><li><strong>Advantages</strong>: Fast convergence, no automatic differentiation overhead, robust step size control</li><li><strong>Disadvantages</strong>: Requires manual derivative computation</li></ul><p><strong>Fields</strong></p><ul><li><code>x0::FT</code>: Initial guess for the root</li></ul><p><strong>Note</strong></p><p>When using this method, your function <code>f</code> should return a tuple <code>(f(x), f&#39;(x))</code> containing both the function value and its derivative at <code>x</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Find root of x^2 - 4, providing both function and derivative
f_and_df(x) = (x^2 - 4, 2x)
method = NewtonsMethod{Float64}(1.0)
sol = find_zero(f_and_df, method)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/RootSolvers.jl/blob/5cb11b0636424fb61d86fa5507eef2a46a6c0b33/src/RootSolvers.jl#L286-L318">source</a></section></article><hr/><h2 id="Solution-Types"><a class="docs-heading-anchor" href="#Solution-Types">Solution Types</a><a id="Solution-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-Types" title="Permalink"></a></h2><p>These types control the level of detail in the output returned by <code>find_zero</code>.</p><table><tr><th style="text-align: left">Solution Type</th><th style="text-align: left">Features</th><th style="text-align: left">Best For</th></tr><tr><td style="text-align: left"><a href="#RootSolvers.CompactSolution"><code>CompactSolution</code></a></td><td style="text-align: left">Minimal output, GPU-friendly</td><td style="text-align: left"><strong>High-performance</strong>, GPU, memory efficiency</td></tr><tr><td style="text-align: left"><a href="#RootSolvers.VerboseSolution"><code>VerboseSolution</code></a></td><td style="text-align: left">Full diagnostics, iteration history</td><td style="text-align: left"><strong>Debugging</strong>, analysis, CPU</td></tr></table><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RootSolvers.CompactSolution" href="#RootSolvers.CompactSolution"><code>RootSolvers.CompactSolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CompactSolution &lt;: SolutionType</code></pre><p>A memory-efficient solution type that returns only essential information about the root.</p><p>When used with <code>find_zero</code>, returns a <code>CompactSolutionResults</code> object containing only the root value and convergence status. This solution type is GPU-compatible and suitable for high-performance applications where memory usage is critical.</p><p><strong>Accessing Results</strong></p><p>The returned <code>CompactSolutionResults</code> object contains the following fields:</p><ul><li><code>sol.root</code>: The found root value</li><li><code>sol.converged</code>: Boolean indicating if the method converged</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sol = find_zero(x -&gt; x^2 - 4, 
               SecantMethod{Float64}(0.0, 3.0), 
               CompactSolution())

# Access the root
println(&quot;Root: $(sol.root)&quot;)

# Check convergence
if sol.converged
    println(&quot;Root found successfully!&quot;)
else
    println(&quot;Method failed to converge&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/RootSolvers.jl/blob/5cb11b0636424fb61d86fa5507eef2a46a6c0b33/src/RootSolvers.jl#L453-L483">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RootSolvers.VerboseSolution" href="#RootSolvers.VerboseSolution"><code>RootSolvers.VerboseSolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VerboseSolution &lt;: SolutionType</code></pre><p>A solution type that returns detailed information about the root-finding process, including iteration history and convergence diagnostics.</p><p>When used with <code>find_zero</code>, returns a <code>VerboseSolutionResults</code> object containing the root, convergence status, error information, and complete iteration history.</p><p><strong>Accessing Results</strong></p><p>The returned <code>VerboseSolutionResults</code> object contains the following fields:</p><ul><li><code>sol.root</code>: The found root value</li><li><code>sol.converged</code>: Boolean indicating if the method converged</li><li><code>sol.err</code>: Final error value (function value at the root)</li><li><code>sol.iter_performed</code>: Number of iterations performed</li><li><code>sol.root_history</code>: Vector of all root values during iteration</li><li><code>sol.err_history</code>: Vector of all error values during iteration</li></ul><p><strong>Note</strong></p><p>This solution type stores iteration history and is primarily intended for CPU computations. For GPU computations or when memory usage is a concern, use <code>CompactSolution</code> instead.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">sol = find_zero(x -&gt; x^2 - 4, SecantMethod(1.0, 3.0), VerboseSolution())

# Access the root
root_value = sol.root

# Check convergence and diagnostics
if sol.converged
    println(&quot;Root found: &quot;, root_value)
    println(&quot;Converged in &quot;, sol.iter_performed, &quot; iterations&quot;)
    println(&quot;Final error: &quot;, sol.err)
else
    println(&quot;Method failed to converge&quot;)
end

# Access iteration history
println(&quot;First iteration root: &quot;, sol.root_history[1])
println(&quot;Last iteration root: &quot;, sol.root_history[end])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/RootSolvers.jl/blob/5cb11b0636424fb61d86fa5507eef2a46a6c0b33/src/RootSolvers.jl#L359-L401">source</a></section></article><hr/><h2 id="Tolerance-Types"><a class="docs-heading-anchor" href="#Tolerance-Types">Tolerance Types</a><a id="Tolerance-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Tolerance-Types" title="Permalink"></a></h2><p>Tolerance types define the convergence criteria for the solver.</p><table><tr><th style="text-align: left">Tolerance Type</th><th style="text-align: left">Criterion</th><th style="text-align: left">Best For</th></tr><tr><td style="text-align: left"><a href="#RootSolvers.SolutionTolerance"><code>SolutionTolerance</code></a>           )</td><td style="text-align: left"><code>abs(x₂ - x₁)</code></td><td style="text-align: left">When you want iterates to <strong>stabilize</strong></td></tr><tr><td style="text-align: left"><a href="#RootSolvers.ResidualTolerance"><code>ResidualTolerance</code></a></td><td style="text-align: left"><code>abs(f(x))</code></td><td style="text-align: left">When you want the function value near <strong>zero</strong></td></tr><tr><td style="text-align: left"><a href="#RootSolvers.RelativeSolutionTolerance"><code>RelativeSolutionTolerance</code></a></td><td style="text-align: left"><code>abs((x₂ - x₁)/x₁)</code></td><td style="text-align: left">When root magnitude <strong>varies widely</strong></td></tr><tr><td style="text-align: left"><a href="#RootSolvers.RelativeOrAbsoluteSolutionTolerance"><code>RelativeOrAbsoluteSolutionTolerance</code></a></td><td style="text-align: left">Relative or Absolute</td><td style="text-align: left"><strong>Robust</strong> for both small and large roots</td></tr></table><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RootSolvers.AbstractTolerance" href="#RootSolvers.AbstractTolerance"><code>RootSolvers.AbstractTolerance</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractTolerance{FT} &lt;: AbstractType</code></pre><p>Abstract type for tolerance criteria in RootSolvers.jl.</p><p>This is the base type for all tolerance types that define convergence criteria for root-finding algorithms. Each concrete tolerance type should implement the callable interface <code>(tol)(x1, x2, y)</code> for convergence checking.</p><p><strong>Type Parameters</strong></p><ul><li><code>FT</code>: The floating-point type for tolerance values (e.g., <code>Float64</code>, <code>Float32</code>)</li></ul><p><strong>Concrete Implementations</strong></p><ul><li><a href="#RootSolvers.ResidualTolerance"><code>ResidualTolerance{FT}</code></a>: Based on <code>|f(x)|</code></li><li><a href="#RootSolvers.SolutionTolerance"><code>SolutionTolerance{FT}</code></a>: Based on <code>|x_{n+1} - x_n|</code></li><li><a href="#RootSolvers.RelativeSolutionTolerance"><code>RelativeSolutionTolerance{FT}</code></a>: Based on <code>|(x_{n+1} - x_n)/x_n|</code></li><li><a href="#RootSolvers.RelativeOrAbsoluteSolutionTolerance"><code>RelativeOrAbsoluteSolutionTolerance{FT}</code></a>: Combined relative and absolute tolerance</li></ul><p><strong>Interface Requirements</strong></p><p>All concrete subtypes must implement:</p><ul><li><code>(tol)(x1, x2, y)</code>: Check convergence using three arguments (previous iterate, current iterate, function value)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Define a custom tolerance type
struct MyTolerance{FT} &lt;: AbstractTolerance{FT}
    threshold::FT
end

# Implement the required interface
(tol::MyTolerance)(x1, x2, y) = abs(x2 - x1) &lt; tol.threshold || abs(y) &lt; eps(typeof(y))

# Use with find_zero
sol = find_zero(x -&gt; x^2 - 4, SecantMethod(1.0, 3.0), CompactSolution(), MyTolerance(1e-6))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/RootSolvers.jl/blob/5cb11b0636424fb61d86fa5507eef2a46a6c0b33/src/RootSolvers.jl#L549-L584">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RootSolvers.SolutionTolerance" href="#RootSolvers.SolutionTolerance"><code>RootSolvers.SolutionTolerance</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SolutionTolerance{FT}</code></pre><p>A convergence criterion based on the absolute difference between consecutive iterates. The iteration stops when <code>|x_{n+1} - x_n| &lt; tol</code>, where <code>tol</code> is the specified tolerance. Convergence is also triggered if |f(x)| is smaller than the machine epsilon for the value type.</p><p>This tolerance is appropriate when you want to ensure that consecutive iterates are sufficiently close, indicating that the solution has stabilized.</p><p><strong>Fields</strong></p><ul><li><code>tol::FT</code>: Tolerance threshold for <code>|x_{n+1} - x_n|</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">tol = SolutionTolerance(1e-8)
sol = find_zero(x -&gt; x^3 - 8, 
               SecantMethod{Float64}(1.0, 3.0),
               CompactSolution(),
               tol)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/RootSolvers.jl/blob/5cb11b0636424fb61d86fa5507eef2a46a6c0b33/src/RootSolvers.jl#L624-L645">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RootSolvers.ResidualTolerance" href="#RootSolvers.ResidualTolerance"><code>RootSolvers.ResidualTolerance</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ResidualTolerance{FT}</code></pre><p>A convergence criterion based on the absolute value of the residual (function value). The iteration stops when <code>|f(x)| &lt; tol</code>, where <code>tol</code> is the specified tolerance (limited to  the machine epsilon of the function value type).</p><p>This tolerance is appropriate when you want to ensure that the function value is sufficiently close to zero, regardless of how close consecutive iterates are.</p><p><strong>Fields</strong></p><ul><li><code>tol::FT</code>: Tolerance threshold for <code>|f(x)|</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">tol = ResidualTolerance(1e-10)
sol = find_zero(x -&gt; x^2 - 4, 
               NewtonsMethodAD{Float64}(1.0),
               CompactSolution(),
               tol)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/RootSolvers.jl/blob/5cb11b0636424fb61d86fa5507eef2a46a6c0b33/src/RootSolvers.jl#L588-L609">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RootSolvers.RelativeSolutionTolerance" href="#RootSolvers.RelativeSolutionTolerance"><code>RootSolvers.RelativeSolutionTolerance</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RelativeSolutionTolerance{FT}</code></pre><p>A convergence criterion based on the relative difference between consecutive iterates. The iteration stops when <code>|(x_{n+1} - x_n)/x_n| &lt; tol</code>, where <code>tol</code> is the specified tolerance.  Convergence is also triggered if |f(x)| is smaller than the machine epsilon for the value type.</p><p>This tolerance is appropriate when you want to convergence relative to the magnitude of the solution, which is useful when the root value might be very large or very small.</p><p><strong>Fields</strong></p><ul><li><code>tol::FT</code>: Relative tolerance threshold</li></ul><p><strong>Warning</strong></p><p>This tolerance criterion can fail if <code>x_n ≈ 0</code> during iteration, as it involves division by <code>x_n</code>. Consider using <code>RelativeOrAbsoluteSolutionTolerance</code> for more robust behavior.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">tol = RelativeSolutionTolerance(1e-6)
sol = find_zero(x -&gt; x^2 - 1e6, 
               NewtonsMethodAD{Float64}(500.0),
               CompactSolution(),
               tol)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/RootSolvers.jl/blob/5cb11b0636424fb61d86fa5507eef2a46a6c0b33/src/RootSolvers.jl#L658-L683">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RootSolvers.RelativeOrAbsoluteSolutionTolerance" href="#RootSolvers.RelativeOrAbsoluteSolutionTolerance"><code>RootSolvers.RelativeOrAbsoluteSolutionTolerance</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RelativeOrAbsoluteSolutionTolerance{FT}</code></pre><p>A robust convergence criterion combining both relative and absolute tolerances. The iteration stops when either <code>|(x_{n+1} - x_n)/x_n| &lt; rtol</code> OR <code>|x_{n+1} - x_n| &lt; atol</code>.</p><p>This tolerance provides robust behavior across different scales of root values:</p><ul><li>The relative tolerance <code>rtol</code> ensures accuracy for large roots</li><li>The absolute tolerance <code>atol</code> ensures convergence when the root is near zero</li></ul><p><strong>Fields</strong></p><ul><li><code>rtol::FT</code>: Relative tolerance threshold</li><li><code>atol::FT</code>: Absolute tolerance threshold</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Use relative tolerance of 1e-6 and absolute tolerance of 1e-10
tol = RelativeOrAbsoluteSolutionTolerance(1e-6, 1e-10)
sol = find_zero(x -&gt; x^2 - 1e-8, 
               NewtonsMethodAD{Float64}(1e-3),
               CompactSolution(),
               tol)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/CliMA/RootSolvers.jl/blob/5cb11b0636424fb61d86fa5507eef2a46a6c0b33/src/RootSolvers.jl#L696-L719">source</a></section></article><hr/><h2 id="Broadcasting-and-High-Performance-Computing"><a class="docs-heading-anchor" href="#Broadcasting-and-High-Performance-Computing">Broadcasting and High-Performance Computing</a><a id="Broadcasting-and-High-Performance-Computing-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting-and-High-Performance-Computing" title="Permalink"></a></h2><p>RootSolvers.jl is designed for high-performance computing applications and supports broadcasting to solve many problems in parallel. This is especially useful for GPU arrays or custom field types used in scientific modeling.</p><p>The custom broadcasting rule unpacks initial guesses from the <code>method</code> struct while treating all other arguments as scalars. This enables a clean API for batch-solving.</p><p>For more information about broadcasting, see the examples in the <code>find_zero</code> documentation.</p><hr/><h2 id="Developer-Documentation"><a class="docs-heading-anchor" href="#Developer-Documentation">Developer Documentation</a><a id="Developer-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-Documentation" title="Permalink"></a></h2><p>For information about internal methods, extending RootSolvers.jl, and developer-focused functionality, see the <a href="../DeveloperDocs/">Developer Documentation</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../GettingStarted/">« Getting Started</a><a class="docs-footer-nextpage" href="../DeveloperDocs/">Developer Documentation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 6 August 2025 13:11">Wednesday 6 August 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
